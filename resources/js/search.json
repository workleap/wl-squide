[[{"i":"#","p":["The documentation for Squide firefly v8 is available here."]},{"l":"Getting started","p":["Welcome to Squide (yes \uD83E\uDD91 with an \"e\"), a React modular application shell tailored for the needs of Workleap web applications. In this getting started section, you'll find an overview of the shell and a quick start guide to create a new application from scratch."]},{"l":"What is Squide?","p":["\"Modular design is not just a trend but a proven strategy for success in software engineering.\"","\"Modular software architecture enables the creation of complex systems by breaking them down into smaller, independent components. This approach enhances reusability, maintainability, and scalability while reducing the development time and cost.\"","API requests mocking","Authentication","By \"modular application\", we mean that much like in backend systems, a web application built with Squide should be organized as a collection of independent modules, each responsible for a specific part of the system (i.e., a domain or subdomain):","Environment variables","Errors handling","Feature","Global data fetching","In addition to modularity, Squide offers built-in mechanisms to handle most of the cross-cutting functionalities of a web application:","Library","Localization","Logging","Messaging","Modular Navigation","Modular Routing","Observability","Public and Protected pages","Squide bootstrapping flow facilitate the implementation of public & protected routes by providing a Tanstack Query wrapper, allowing applications to only load their protected data (session related data) if the requested route is protected. Additionally, Squide bootstrapping flow is smart enough to delay the rendering of the requested page until the initial data of an application is ready.","Squide extends React Router, adding modular routing capabilities.","Squide includes a built-in logger powered by @workleap/logging.","Squide includes built-in observability powered by Honeycomb.","Squide includes built-in support for localization, powered by i18next.","Squide integrates with Storybook stories.","Squide is a React modular application shell tailored for the needs of Workleap's web applications. It enforces architectural patterns that we deem important to write scalable and maintainable web applications at Workleap.","Storybook","Those cross-cutting functionalities uses most of the libraries recommended by Workleap's frontend technology stacks:","When in development, Squide bootstrapping flow ensure that the rendering of the requested page is delayed until all of the application MSW request handlers has been registered."]},{"l":"Why is Squide relevant?","p":["Short version:","\uD83D\uDC4C Encourage modularity","\uD83D\uDED1 Stop reinventing the wheel","\uD83D\uDCC9 Lower product operating costs","\uD83D\uDCC8 Boost product development velocity","\uD83D\uDE85 Accelerate time to market for initial product releases","âœ¨ Enhance product quality and maintainability with a well designed API, tests suites and documentation","Long version:","Every Workleap's frontend applications must implement, to some extent, most of the cross-cutting functionalities listed in the previous section of this document. Implementing those cross-cutting functionalities require significant effort, typically involving senior or staff frontend developers and taking a few months of full-time work to complete(when done right). This process can slow down product teams, impact their velocity and delay the initial release of a new product.","Squide helps reduce both the initial development costs and the ongoing maintenance costs of frontend applications by offering a reusable, well-tested, and thoroughly documented solution developed by experienced frontend engineers. Squide streamlines the implementation of cross-cutting functionalities, allowing product teams to focus on delivering value without reinventing the wheel.","Having a well-tested and well-documented shell is a significant advantage, as application shell code is often poorly understood by product teams and typically lacks proper testing and documentation, which complicates the maintenance of a custom application shell.","By providing most of the required cross-cutting functionalities out of the box, Squide enables product teams to reduce their operating costs by minimizing the need for dedicated staff developers to build and maintain a custom application shell."]},{"l":"Create your project","p":["\uD83D\uDC49 To get started, follow the quick start guide to create a new Squide's application from scratch."]},{"l":"Module Federation","p":["Originally, Squide has been developed as a micro frontend application shell to ease the adoption of distributed applications at Workleap. While Squide remains a great shell for micro frontends applications, as our product strategy shifted to Hero products and most of Workleap's products moved away from distributed applications, we discovered that Squide also offers significant value for non-federated web applications. Therefore, we continue to invest into Squide and now describe it as a shell for modular applications, supporting both remote modules and local modules in hybrid mode.","The benefit of supporting both approaches in hybrid mode is that Workleap's products can initially be developed with local modules, which help separate concerns from the start, enabling teams to work independently and focus on specific areas of the application. As the product grows and encounters organizational scalability challenges, teams can seamlessly migrate local modules one by one into standalone remote modules powered by Module Federation without requiring updates to the application's core code.","\uD83D\uDC49 To get started with a micro frontrends application, follow the Module Federation quick start guide to create a new Squide's application from scratch."]}],[{"l":"Create an host application","p":["We highly recommend going through the entire getting started guide. However, if you prefer to scaffold the application we'll be building, a template is available with degit:","Let's begin by creating the application that will serve as the entry point for our modular application and host the application modules."]},{"l":"Install the packages","p":["Create a new application (we'll refer to ours as host), then open a terminal at the root of the new solution and install the following packages:"]},{"l":"Setup the application","p":["First, create the following files:","Then, ensure that you are developing your application using ESM syntax by specifying type: module in your package.json file:"]},{"l":"Module registration","p":["Next, to register the modules, instanciate a shell FireflyRuntime instance. A local module will be registered in the next section of this quick start guide:","Then, render the AppRouter component to define a React Router browser instance configured with the registered routes:"]},{"l":"Navigation items","p":["Next, create a layout component to render the navigation items. In many applications, multiple pages often share a common layout that includes elements such as a navigation bar, a user profile menu, and a main content section. In a React Router application, this shared layout is commonly referred to as a RootLayout:","The RootLayout component created in the previous sample will serves as the default layout for the homepage as well as for every page (route) registered by a module that are not nested under a parent route with either the parentPath or the parentId option."]},{"l":"Homepage","p":["Next, create the HomePage component that will serve as the homepage:","Then, add a local module at the root of the host application to register the homepage:","And, update the bootstrapping code to register the newly created local module:"]},{"l":"Register the root layout","p":["Finally, add an hoisted route to render the RootLayout with the PublicRoutes and ProtectedRoutes placeholders:","The PublicRoutes and ProtectedRoutes placeholders indicates where routes that are neither hoisted or nested with a parentPath or parentId option will be rendered. In this example, the homepage route is considered as a protected route and will be rendered under the ProtectedRoutes placeholder."]},{"l":"Not found page (404)","p":["Now, let's ensure that users who enter a wrong URL end up somewhere by registering a custom no-match route. First, create the NotFoundPage component, which will serve as the page for handling not found routes:","Then, register the newly created component as the * route:"]},{"l":"Configure Rsbuild","p":["For additional information about this Rsbuild setup, refer to the development and production configuration documentation of the Web Configs libraries.","First, open the public/index.html file created at the beginning of this guide and copy/paste the following template:","Then, open the .browserslist file and copy/paste the following content:"]},{"l":"Development configuration","p":["To configure Rsbuild for a development environment, open the rsbuild.dev.ts file and use the defineDevConfig function to configure Rsbuild:"]},{"l":"Build configuration","p":["To configure Rsbuild for a build environment, open the rsbuild.build.ts file and use the defineBuildConfig function to configure Rsbuild:"]},{"l":"Add CLI scripts","p":["To initiate the development server, add the following script to the application package.json file:","To build the application, add the following script to the application package.json file:"]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the application in a development environment using the dev script. You should see the homepage."]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this guide:","Open the DevTools console. You'll find a log entry for each registration that occurs and error messages if something went wrong:","[squide] Found 1 local module to register.","[squide] 1/1 Registering local module.","[squide] 1/1 Local module registration completed.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Create a local module","p":["We highly recommend going through the entire getting started guide. However, if you prefer to scaffold the application we'll be building, a template is available with degit:","Local modules expose a registration function to the host application's bootstrapping code. A local module can be a standalone package, a sibling project (in a monorepo setup), or even a local folder within the host application.","Let's add a local module to demonstrate how it's done!"]},{"l":"Install the packages","p":["Create a new application (we'll refer to ours as local-module), then open a terminal at the root of the application and install the following packages:"]},{"l":"Setup the application","p":["First, create the following files:","Then, ensure that you are developing your module using ESM syntax by specifying type: module in your package.json file:","Then, configure the package to be shareable by adding the name, version, and export fields to the package.json file:","For more information about the exports field, refer to this resource on Just-In-Time Packages.","Finally, add the following peerDependencies:"]},{"l":"Routes registration","p":["Next, register the local module routes and navigation items with registerRoute and registerNavigationItem functions:","Then, create the Page component:"]},{"l":"Register the local module","p":["Go back to the host application and add a dependency to the @getting-started/local-module package in the host application package.json file:","If your project is set up as a monorepo, use workspace:* for the version instead of 0.0.1.","Then, register the local module with the initializeFirefly function:"]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the host application in development mode using the dev script. You should notice an additional link labelled Local/Page in the navigation menu. Click on the link to navigate to the page of your new local module!"]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this guide:","Open the DevTools console. You'll find a log entry for each registration that occurs and error messages if something went wrong:","[squide] The following route has been registered.","[squide] The following static navigation item has been registered to the root menu for a total of 2 static items.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Learn the modular design principles","p":["While developing the API of Squide, we kept a few modular design principles in mind. Those principles are not settled stones, you might want to diverge from them from time to time, but adhering to those will make your experience more enjoyable:","A module should correspond to a domain or subdomain of the application.","A module should be autonomous.","A module should not directly reference the other modules of the application. To coordinate with other modules, including the host application, a module should always use Squide's Runtime API.","A modular application should feel cohesive. Different parts of the application should have the ability to communicate with each others and react to changes happening outside of their boundaries (without taking an hard reference on other parts of the application).","Data and state should never be shared between modules. Even if two modules require the same data or the same state values, they should load, store and manage those independently."]}],[{"l":"Learn the core pieces","p":["Now that we've created a host application, loaded a few modules, registered routes and navigation items, and learn the modular design principles, let's delve into the core pieces provided by Squide."]},{"l":"Runtime","p":["The runtime instance serves as the backbone of a Squide application, enabling modularity and maintaining a decoupled and extendable system. It's purpose is to configure and manage the environment of the application, register the modules and plugins, and centralize cross-cutting concerns such as messaging, logging, telemetry/observability, environment variables and feature flags."]},{"l":"Learn more","p":["Reference documentation"]},{"l":"Modular registration","p":["Squide enables developers to build scalable modular applications with well-defined boundaries by allowing consumers to register dynamic routes, navigation items and MSW request handlers in modules. Each module contributes its own routing configuration, which the host application then assembles into unified structures at bootstrapping. This keeps routing, navigation and request handlers isolated within each module."]},{"i":"the-drawbacks-of-a-tightly-coupled-architecture","l":":icon-light-bulb: The drawbacks of a tightly coupled architecture","p":["The opposite of a modular architecture is a tightly coupled architecture. This style of architecture often evolves into what is commonly described as a \"big ball of mud\". As the codebase grows, teams face increasing maintenance difficulties, scaling limitations, and unpredictable side effects.","Systems with highly coupled architectures are typically characterized by:","Unclear internal structure","Weak boundaries","High coupling","Low cohesion","Inconsistent design decisions","While such an architecture seems appropriate during the first weeks or months of a project, problems emerge quickly as the system grows:","Harder to understand: The codebase lacks boundaries and consistent patterns, making it difficult for developers to build a clear mental model. Logic becomes scattered across unrelated areas of the system.","Higher cost of change and risk of regressions: Modifying one part of the system often produces unexpected side effects elsewhere. The tight coupling increases the likelihood of regressions.","Slower onboarding: New developers take longer to understand the system due to the absence of clear boundaries and scattered logic.","Increased coordination needs: As more teams contribute to the same codebase, they frequently touch overlapping areas. This requires cross-team synchronization and generates coordination overhead.","Slower releases: Testing and releasing new features require validating the entire system, extending release cycles.","Unclear ownership: Without well-defined boundaries, ownership becomes ambiguous. This slows decision-making and complicates maintenance responsibilities.","Growing accidental complexity: Temporary workarounds accumulate rather than being replaced by proper abstractions, causing technical debt to rise quickly."]},{"i":"code-sample","l":":icon-file-code: Code sample"},{"i":"learn-more-1","l":"Learn more","p":["Register routes","Register navigation items","Register deferred navigation items","Register MSW request handlers","Setup MSW"]},{"l":"Public and protected pages","p":["Modules can declare routes which are meant to be publicly accessible or that are protected (requires an authentication). Squide built-in primitives handles the bootstrapping orchestration to:","Fetch only the public global data if the requested page is registered as \"public\".","Fetch only the protected global data if the requested page is registered as \"protected\"."]},{"i":"code-sample","l":":icon-file-code: Code sample"},{"i":"learn-more-2","l":"Learn more","p":["Register a public route","Setup Tanstack Query","Fetch public global data","Fetch protected global data"]},{"l":"Global data fetching","p":["Squide makes global protected data fetching easier, by providing primitives build on top of Tanstack Query to orchestrate both the data-loading states and the associated UI."]},{"i":"the-challenges-with-global-data","l":":icon-light-bulb: The challenges with global data","p":["At first glance, one might wonder what could be so complicated about fetching the global data of an application. It's only fetches ...right? Well, there are several concerns to take into account for a modular application:","When in development, the global data cannot be fetched until the Mock Service Worker (MSW) request handlers are registered and MSW is ready.","To register the MSW request handlers, the modules must be registered first.","If the requested page is public, only the global public data should be fetched.","If the requested page is protected, both the global public and protected data should be fetched.","The requested page rendering must be delayed until the global data has been fetched.","A unique loading spinner should be displayed to the user during this process, ensuring there's no flickering due to different spinners being rendered."]},{"i":"code-sample","l":":icon-file-code: Code sample"},{"i":"learn-more-3","l":"Learn more","p":["Setup Tanstack Query","Fetch public global data","Fetch protected global data"]},{"l":"Messaging","p":["Squide event bus offers a pub/sub mechanism for modules to communicate through events without creating tight coupling."]},{"i":"code-sample","l":":icon-file-code: Code sample"},{"i":"learn-more-4","l":"Learn more","p":["Use the event bus"]},{"l":"Logging","p":["Squide logger provides visibility into the application's bootstrapping flow and how modules behave and interact. It also offers an abstraction that allows applications to emit custom logs to multiple destinations defined by the host application."]},{"i":"code-sample","l":":icon-file-code: Code sample"},{"i":"learn-more-5","l":"Learn more","p":["Setup the logger","Use the logger"]},{"l":"Environment variables","p":["Squide attaches environment variables to a FireflyRuntime instance rather than accessing process.env throughout the codebase. This strategy supports a modular architecture and makes it easier to write tests and Storybook stories by isolating configuration from global state and making environment variables independent from build-time specifics."]},{"i":"code-sample","l":":icon-file-code: Code sample"},{"i":"learn-more-6","l":"Learn more","p":["Use environment variables"]},{"l":"Honeycomb","p":["Squide integrates with @workleap/telemetry v2 or later (or @workleap/honeycomb v7 or later) to automatically send performance traces for the bootstrapping flow of an application."]},{"i":"code-sample","l":":icon-file-code: Code sample"},{"i":"learn-more-7","l":"Learn more","p":["Setup Honeycomb","Set Honeycomb custom attributes"]},{"l":"Plugins","p":["To keep Squide lightweight, not all functionalities should be integrated as a core functionality. However, to accommodate a broad range of technologies, a plugin system has been implemented to fill the gap."]},{"i":"learn-more-8","l":"Learn more","p":["Register plugins"]},{"i":"code-sample","l":":icon-file-code: Code sample"},{"l":"Integrations","p":["To finish setting up Squide, continue with the integration guides."]},{"l":"Reference","p":["For an exhaustive list of the Squide API, refer to the reference section."]},{"l":"Samples","p":["Finally, have a look at the sample applications to see the Squide API in action."]}],[{"l":"Deploy","p":["The deployment process for a modular application can vary depending on various factors, including the chosen hosting provider. Therefore, we do not recommend any specific deployment setup.","However, there are a few essential configurations that need to be made regardless of your architectural and deployment choices."]},{"l":"Add a default redirect","p":["To enable support for direct page hits, add the following redirect rule to your host application's hosting provider:","For Netlify, it can either be with a netlify.toml file at the root of project:","Or by adding a _redirects file into the Netlify publish directory:"]},{"l":"Set the remote URL","p":["If your modular applications includes remote modules, configure the remote modules production URL:"]},{"l":"Update the runtime mode","p":["Don't forget to change the runtime mode to production:"]},{"l":"Register a LogRocket logger","p":["If your application uses LogRocket, register a LogRocketLogger instance to capture log entries in LogRocket session replays:"]}],[{"l":"Integrations","p":["Setup MSW","Setup Honeycomb","Setup Tanstack Query","Setup i18next","Setup the logger","Setup Storybook"]}],[{"l":"Setup MSW","p":["Squide includes built-in support for Mock Service Worker(MSW) to speed up frontend development and promote an API first approach. Modules can dynamically register their own mock request handlers, and Squide composes them into a unified set."]},{"l":"Configure the host application"},{"l":"Initialize MSW","p":["First, initialize MSW by executing the following command at the root of the host application:"]},{"l":"Create a start function","p":["Then, create a function to start MSW with the modules request handlers:"]},{"l":"Update the bootstrapping code","p":["Finally, refer to the create an host application guide as a starting point and update the bootstrapping code to conditionally enable MSW based on an environment variable, and call the startMsw function when MSW is active:"]},{"i":"define-the-use_msw-environment-variable","l":":icon-file-code: Define the `USE_MSW` environment variable","p":["First open a terminal at the root of the host application and install the cross-env package:","Then, update the dev PNPM script to define with cross-env an USE_MSW environment variable:","Finally, update the development Rsbuild configuration file to include the USE_MSW environment variable into the application bundles:","For additional information about the environmentVariables predefined option, refer to the Rsbuild configuration documentation.","Make sure to define the USE_MSW environment variable for the build configuration as well."]},{"l":"Fetch the handler data","p":["Next, follow the fetch page data essential page to register an MSW handler and fetch its data from a page using TanStack Query."]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the application in development mode using the dev script. You should notice that the data has been fetched from the request handler.","In Chrome devtools, the status code for a successful network call that has been handled by an MSW request handler will be 200 OK (from service worker)."]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this guide:","Open the DevTools console. You'll find a log entry for each request handlers registration that occurs and error messages if something went wrong:","[squide] The following MSW request handlers has been registered: [...]","[squide] MSW is ready.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Setup Honeycomb","p":["Squide integrates with @workleap/telemetry v2 or later (or @workleap/honeycomb v7 or later) to automatically send performance traces for the bootstrapping flow of an application."]},{"l":"Configure the host application"},{"l":"Install the packages","p":["To set up Honeycomb, first, open a terminal at the root of the host application and install the following packages:"]},{"l":"Register the instrumentation","p":["Then, refer to the create an host application guide as a starting point and update the host application bootstrapping code to register Honeycomb instrumentation:","For additional information about this Honeycomb instrumentation setup, refer to the @workleap/telemetry library documentation.","Avoid using /.+/g, in production, as it could expose customer data to third parties. Instead, ensure you specify values that accurately matches your application's backend URLs.","We recommend using an OpenTelemetry collector over an ingestion API key, as API keys can expose Workleap to potential attacks. To use a collector, set the proxy option with your collector's proxy address.","With instrumentation in place, a few traces are now available \uD83D\uDC47"]},{"l":"Bootstrapping flow","p":["The performance of an application bootstrapping flow can now be monitored:","Bootstrapping flow performance"]},{"l":"Deferred registration update","p":["When a deferred registration is updated, the performance of the operation can be monitored:","Deferred registration update performance"]},{"l":"Fetch requests","p":["Individual fetch request performance can be monitored from end to end:","Fetch instrumentation"]},{"l":"Document load","p":["The loading performance of the DOM can be monitored:","Document load instrumentation"]},{"l":"Unmanaged error","p":["When an unmanaged error occurs, it's automatically recorded:","Recorded error"]},{"l":"Real User Monitoring (RUM)","p":["The default instrumentation will automatically track the appropriate metrics to display RUM information:","Largest Contentful Paint","Cumulative Layout Shift","Interaction to Next Paint"]},{"l":"Set custom user attributes","p":["Refer to the set Honeycomb custom attributes essential page."]},{"l":"Custom traces","p":["To send custom traces to Honeycomb, applications should use the OpenTelemetry API directly:"]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the application in a development environment using the dev script. Render a page, then navigate to your Honeycomb instance. Go to the Query page and type root.name = squide-bootstrapping into the Where input. Run the query, select the Traces tab at the bottom of the page and view the detail of a trace. You should view the performance of your application bootstrapping flow."]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this guide:","Set the initializeTelemetry function verbose option to true.","Open the DevTools console. You'll see a log entry for every for each dispatched event, along with multiple console outputs from Honeycomb's SDK. Squide's bootstrapping instrumentation listens to events to send Honeycomb traces. Most events should match an Honeycomb trace and vice versa.","[squide] Honeycomb instrumentation is registered","[squide] Dispatching event squide-local-modules-registration-completed","[squide] Dispatching event squide-remote-modules-registration-completed","[squide] Dispatching event squide-public-data-fetch-started","[squide] Dispatching event squide-public-data-ready","@honeycombio/opentelemetry-web: Honeycomb link: ...","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Setup TanStack Query","p":["TanStack Query simplifies server state management in frontend applications by keeping backend data synchronized with the UI without requiring manual state handling. It uses a default \"stale-while-revalidate\" caching strategy, which prioritizes a responsive user experience by showing cached (possibly stale) data immediately while fetching updated data in the background."]},{"i":"what-is-stale-while-revalidate","l":":icon-light-bulb: What is stale-while-revalidate?","p":["\"stale-while-revalidate refers\" to a caching strategy where previously fetched data is shown immediately (even if it's outdated), while the library fetches fresh data in the background to update the UI once the new result arrives.","Here's the idea in simple terms:","Serve stale data instantly: If data exists in the cache, TanStack Query returns it right away, even if it's considered stale. This keeps the UI fast and responsive.","Revalidate (refetch) in the background: At the same time, TanStack Query automatically triggers a background refetch to get the most recent data from the server.","Update the UI when fresh data arrives: Once the refetch completes, the new data replaces the stale data, and components automatically re-render."]},{"l":"Setup the query client","p":["To setup TanStack client, refer to the create an host application guide as a starting point and update the host application bootstrapping code with a QueryClientProvider:"]},{"l":"Setup the development tools","p":["TanStack Query Devtools provide real-time visibility into how your application manages server state. They make it easier to understand, debug, and optimize data-fetching behavior by exposing the details that normally operate behind the scenes.","We recommend giving the Devtools a try during development.","To setup the development tools, first open a terminal at the root of the host application and install the following package:","Then, update the bootstrapping code to add a ReactQueryDevtools component:","By default, React Query Devtools are only included in bundles when process.env.NODE_ENV === development, so you don't need to worry about excluding them during a production build."]},{"i":"what-are-the-devtools-benefits","l":":icon-light-bulb: What are the Devtools benefits?","p":["Inspect query states (idle, loading, success, error, stale vs fresh)","View cached data (what data is cached, when it updates, whether stale-time or cache-time settings work as intended)","Observe refetching behavior (window refocus, network reconnect, manual invalidation, background updates)","Monitor query lifecycles","Debug errors quickly","Experiment with invalidation and refetching"]},{"l":"Add a suspense boundary","p":["To add a suspense boundary, refer to the create an host application guide and update the layout component by adding a Suspense boundary. This enables the use of the useSuspenseQuery hook inside pages:"]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Go through the fetch page data essential page steps, then, start the application in a development environment using the dev script, then, navigate to the /page page.","You should notice that the character's data is being fetch from the MSW request handler and rendered on the page. Additionally, you should notice that the TanStack Query devtools are available (a ribbon at the bottom right corner)."]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this section of the guide:","Open the DevTools console. You'll find a log entry for each registration that occurs (including MSW request handlers) and error messages if something went wrong.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Setup i18next","p":["react-i18next is an internationalization library that helps applications manage translations, language detection, and localization logic. It provides a flexible API for loading translation files, formatting text, handling plurals, and switching languages at runtime."]},{"l":"Configure the host application"},{"l":"Install the packages","p":["To set up i18next, first, open a terminal at the root of the host application and install the following packages:"]},{"l":"Register the i18nextPlugin","p":["Then, refer to the create host application guide as a starting point and update the host application boostrapping code to register an instance of the i18nextplugin with the FireflyRuntime instance:"]},{"i":"user-language-detection-order","l":":icon-light-bulb: User language detection order","p":["By calling the detectUserLanguage method of the plugin instance, the user language is automatically detected. Applications should always detect the user language at bootstrapping, even if the current language is expected to be overriden by a preferred language setting once the user information has been loaded.","The language detection happens in the following order:","Deduce from a ?language querystring parameter.","Deduce from the user navigator language settings.","Use the fallback language, which is en-US in this example."]},{"l":"Integrate a backend language setting","p":["For many applications, the displayed language is expected to be derived from an application specific user \"preferred language\" setting stored in a remote database. Therefore, the frontend remains unaware of this setting value until the user session is loaded.","Hence, the strategy to select the displayed language should be as follow:","Use the language detected at bootstrapping for anonymous users (with the detectUserLanguage method previously called).","Upon user authentication and session loading, if a \"preferred language\" setting is available from the session data, update the displayed language to reflect this preference.","This strategy can be implemented with the help of the useChangeLanguage and useProtectedDataQueries hooks:"]},{"i":"sampleshared","l":":icon-file-code: @sample/shared"},{"l":"Setup a module"},{"l":"Define a localized resource file","p":["First, create localized resource files for the en-US and fr-CA locales:"]},{"l":"Register an i18next instance","p":["Then, update the host application local module's register function to create and register an i18next instance with the i18nextPlugin instance. Due to how the internals of i18next works, each module (including the host application) must create its own instance of the third-party library. The i18nextPlugin instance will handle synchronizing the language changes across all i18next instances:","The examples in this guide load all the resources from single localized resources files. For a real Workleap application, you probably want to spread the resources into multiple files and load the files with a i18next backend plugin."]},{"l":"Localize a page resource","p":["Then, update the Page component to use the newly created localized resource:"]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the application in a development environment using the dev script. Navigate to /page, the page content and the navigation item should render the english ( en-US) resources. Then append ?language=fr-CA to the URL. The page content and the navigation item should now render the french ( fr-CA) resources."]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this guide:","Open the DevTools console. You'll find a log entry for each i18next instance that is being registered and another log everytime the language is changed:","[squide] Registered a new i18next instance with key local-module.","[squide] The language has been changed to fr-CA.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Setup the logger","p":["Squide logger provides visibility into the application's bootstrapping flow and how modules behave and interact. It also offers an abstraction that allows applications to emit custom logs to multiple destinations defined by the host application.","By default, when running in development mode, a BrowserConsoleLogger is automatically added if no custom loggers are provided through the loggers option of the initializeFirefly function."]},{"l":"Configure loggers","p":["To replace the default console logging behavior, configure your own loggers during initialization:","To keep logging to the console, first, open a terminal at the root of the host application and install the @workleap/logging package:","Then, explicitly provide a BrowserConsoleLogger instance:"]},{"l":"Capture logs in LogRocket","p":["To capture logs in LogRocket session replays, first, open a terminal at the root of the host application and install the @workleap/logrocket package:","Then, provide an instance of LogRocketLogger at initialization:"]},{"l":"Enable console logging in production","p":["To log to the browser console when Squide is running in production mode, first, open a terminal at the root of the host application and install the @workleap/logging package:","Then, provide an instance of BrowserConsoleLogger at initialization:"]},{"l":"Custom logs","p":["Once loggers are configured, the application can output custom log entries using either the useLogger hook or the FireflyRuntime instance.","For more details, refer to the use the logger essential page."]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the application in a development environment. Open the DevTools console, render a page, and look for log entries such as:","[squide] Found X local modules to register.","[squide] 1/X Registering local module.","[squide] Successfully registered local module."]}],[{"l":"Setup Storybook","p":["Squide provides helpers to set up a Storybook story file for rendering components using Squide Firefly. This guide assumes that you already have a working Storybook environment."]},{"l":"Configure Storybook"},{"l":"Install the packages","p":["To set up Storybook, first, open a terminal at the root of the Storybook application and install the following packages:"]},{"l":"Register the MSW addon","p":["Then, update the standard .storybook/preview.tsx file and register the Mock Service Worker(MSW) addon:","Finally, update the standard .storybook/main.ts file and set the staticDirs option to [public]:","Verify that MSW is properly initialized, e.g. confirm that a mockServiceWorker.js file has been generated in the /public folder."]},{"l":"Configure a project"},{"i":"install-the-packages-1","l":"Install the packages","p":["To set up a project, first, open a terminal at the project root and install the following packages:"]},{"l":"Create a runtime instance","p":["Then, update the story files to create a runtime instance using the initializeFireflyForStorybook function:"]},{"l":"Setup a decorator","p":["Then, set up a decorator using the withFireflyDecorator function:","Or embed the FireflyDecorator component in an existing decorator:"]},{"l":"Setup MSW","p":["Finally, forward the MSW request handlers registered by the modules to the Storybook addon:"]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the Storybook application using the development script. Then open a story that uses Squide firefly components. It should render without errors. Make a change to the story and confirm that it re-renders correctly."]}],[{"l":"Essentials","p":["Register routes","Register navigation items","Register deferred navigation items","Register MSW request handlers","Fetch public global data","Fetch protected global data","Fetch page data","Use the logger","Use the event bus","Use environment variables","Set Honeycomb custom attributes","Localize resources","Register plugins","Define error boundaries"]}],[{"l":"Register routes","p":["By allowing consumers to register dynamic routes, Squide enables developers to build scalable modular applications with well-defined boundaries. Each module contributes its own routing configuration, which the host assembles into a unified routing structure at bootstrapping.","Below are the most common use cases. For more details, refer to the reference documentation."]},{"l":"Register a basic route","p":["Typically, simple routes using only the path and element options will be defined:"]},{"l":"Register a route with an id","p":["The registerRoute function accepts a parentId option, allowing a route to be nested under an existing parent route. When searching for the parent route matching the parentId option, the parentId will be matched against the $id option of every route.","Here's an example of a \"pathless\" route with an id:"]},{"l":"Register a nested route","p":["React router nested routes enable applications to render nested layouts at various points within the router tree. This is quite helpful for modular applications as it enables composable and decoupled UI.","To fully harness the power of nested routes, the registerRoute function allows a route to be registered under any previously registered route, even if that route was registered by another module. The only requirement is that the parent route must have been registered with the registerRoute function.","When registering a new route with the registerRoute function, to render the route under a parent route, specify a parentPath option that matches the parent route's path option:","Or a parentId option that matches the parent route's $id option:","The path option of a route rendered under an existing parent route must be a React Router absolute path (a path starting with a /). For example, if a parent route path is /layout, the path option of a route rendered under that parent route and responding to the /page-1 url, should be /layout/page-1.","Routes can also be nested by registering multiple routes in a single registration block:","A single registration block routes can also be define routes with relative paths(rather than starting with a /):"]},{"l":"Register an hoisted route","p":["Unlike a regular route, a hoisted route is added directly at the root of the router. This gives it full control over its rendering, as it is not nested under any root layouts. To mark a route as hoisted, include the hoist option in the route configuration:","To avoid breaking the entire application when an hoisted route encounters unhandled errors, it is highly recommended to declare a React Router's errorElement property for each hoisted route.","If the hoisted route requires an authentication, make sure to wrap the route with an authentication boundary or to handle the authentication within the route."]},{"i":"what-does-hoist-means","l":":icon-light-bulb: What does \"hoist\" means?","p":["Package managers supporting workspaces such as Yarn and NPM call this mechanism \"hoisting\", which means \"raise (something) by means of ropes and pulleys\". This is exactly what we are trying to achieve here.","Squide has a built-in hoist functionality capable of raising module routes marked as hoist at the root of the routes array, before the root layout declaration. Thus, an hoisted route will not be wrapped by the root layout component (or any components) and will have full control over its rendering.","In this example, if we defined both an authentication boundary and a root layout, page-1 would become a sibling of the authentication boundary rather than one of its children:"]},{"l":"Register a public route","p":["When registering a route, a value can be provided indicating whether the route is public or protected. This is especially useful when dealing with code that fetches global data for protected routes(e.g. a session). Although a route definition accepts a $visibility value, we recommended using the runtime registerPublicRoute function to register a root public route instead.","To define a nested route as public, use the $visibility option:","When no $visibility indicator is provided, a route is considered protected."]},{"l":"Register a not found route","p":["A no-match route can be defined to catch invalid or unknown URLs. To do this, register a route with * as the path:"]}],[{"l":"Register navigation items","p":["By allowing consumers to register dynamic navigation items, Squide enables developers to build scalable modular applications with well-defined boundaries. Each module contributes its own navigation items, which the host assembles into a unified application.","Below are the most common use cases. For more details, refer to the reference documentation."]},{"l":"Register a basic item","p":["Typically, simple navigation items using only the $id, $label and to options will be defined:","We recommend always providing an $id option for a navigation item, as it ensures the menus doesn't flicker when deferred registrations are updated. Be sure to use a unique identifier.","The registerNavigationItem function accepts a sectionId option, allowing a navigation item to be nested under an existing navigation section. When searching the parent navigation section matching the sectionId option, the sectionId will be match against the $id option of every navigation item."]},{"l":"Register a nested item","p":["Similarly to nested routes, a navigation item can be nested under an existing section be specifying a sectionId option that matches the section's $id option:","Navigation items can also be nested by registering multipe items in a single registration block:"]},{"l":"Register an item with a sorting priority","p":["A $priority option can be defined for a navigation item to affect it's position in the menu. The sorting algorithm is as follow:","By default a navigation item have a priority of 0.","If no navigation item have a priority, the items are positioned according to their registration order.","If an item have a priority 0, the item will be positioned before any other items with a lower priority (or without an explicit priority value).","If an item have a priority 0, the item will be positioned after any other items with a higher priority (or without an explicit priority value)."]},{"l":"Use dynamic segments for an item link","p":["Sometimes a route's path depends on dynamic contextual values. To support those routes, navigation items can be defined with dynamic segments:"]},{"l":"Use a React element in an item label","p":["Navigation item labels are not limited to plain text. For greater flexibility, a label can contain any React component:"]},{"l":"Style an item","p":["Sometimes a module knows best how its navigation items should be styled. To enforce a specific style on a navigation item, define the style option:"]},{"l":"Open an item link in a new tab","p":["To open a navigation item in a new tab, set the target option to _blank:"]},{"l":"Conditionally render an item","p":["The $canRender native property can be used to indicate whether a navigation item should be rendered by the layout:","It's the responsibility of the code rendering the menu to execute the navigation items $canRender function and conditionally render the items based on the return value."]},{"i":"layout-code-example","l":":icon-file-code: Layout code example"},{"l":"Render additional props on an item","p":["Any properties defined in the $additionalProps option will be forwarded to the layout:","It's the responsibility of the code rendering the menu to handle the additional properties."]},{"i":"layout-code-example","l":":icon-file-code: Layout code example"},{"l":"Navigation menu","p":["By default, every navigation item registered through registerNavigationItem is added to the root navigation menu. The navigation items API also supports defining additional menus."]},{"l":"Define a menu","p":["To define an additional menu in a layout or page, retrieve the navigation items associated with that menu by passing the menu's identifier to the useNavigationItems hook using the menuId option:","Then, render the additional menu items using the useRenderedNavigationItems hook:"]},{"l":"Register an item in a menu","p":["Finally, register navigation items specifically for this additional menu using the menuId option when registering the items:"]},{"l":"Localize an item label","p":["Refer to the localize resources essential page."]}],[{"l":"Register deferred navigation items","p":["Navigation items cannot always be registered before the application bootstrapping process, as some of them depend on remote data retrieved asynchronously from the backend-for-frontend or a third-party service.","To address this, Squide offers an alternate deferred registration mechanism in two-phases:","The first phase allows modules to register their static navigation items that are not dependent on remote data.","The second phase enables modules to register deferred navigation items that are dependent on remote data by returning a function. We refer to this second phase as deferred registrations.","For more details, refer to the initializeFirefly and useDeferredRegistrations reference documentation."]},{"l":"Register a deferred item","p":["To defer a registration to the second phase, a module's registration function can return an anonymous function matching the DeferredRegistrationFunction type: (data, operation: register | update) = Promise | void:","It's important to register conditional navigation items using the deferredRuntime argument rather than the root runtime argument.","It's the responsibility of the application shell code to execute the deferred registrations once the remote data is retrieved."]},{"i":"shell-code-example","l":":icon-file-code: Shell code example"},{"l":"Update deferred items","p":["Since Squide integrates with TanStack Query, and TanStack queries regularly fetch fresh data from the server, the remote data on which deferred navigation items depend may change over time. When this happens, the deferred navigation items must update to reflect the current state of the application. For example, a user might be promoted from a regular user to an administrator and should then see additional navigation items.","By using the useDeferredRegistrations hook in combination with a TanStack Query, deferred registrations are automatically updated whenever the data object passed to useDeferredRegistrations changes:"]}],[{"l":"Register MSW request handlers","p":["By allowing consumers to register dynamic request handlers, Squide enables developers to build scalable modular applications with well-defined boundaries. Each module contributes its own Mock Service Workers, which the host assembles into a unified set.","For more details, refer to the reference documentation."]},{"l":"Register an handler","p":["Before registering a handler, make sure MSW is enabled by checking with isMswEnabled. This prevents MSW handlers from being registered in production.","Always use dynamic imports for files that reference MSW packages to avoid including unused MSW code in production bundles."]},{"l":"Setup MSW","p":["Refer to the Setup MSW integration guide."]}],[{"l":"Fetch public global data","p":["To make global protected data fetching easier, Squide provides primitives build on top of Tanstack Query to orchestrate both the data-loading states and the associated UI.","For more details, refer to the reference documentation."]},{"i":"the-challenges-with-global-data","l":":icon-light-bulb: The challenges with global data","p":["At first glance, one might wonder what could be so complicated about fetching the global data of an application. It's only fetches ...right? Well, there are several concerns to take into account for a modular application:","When in development, the global data cannot be fetched until the Mock Service Worker (MSW) request handlers are registered and MSW is ready.","To register the MSW request handlers, the modules must be registered first.","If the requested page is public, only the global public data should be fetched.","If the requested page is protected, both the global public and protected data should be fetched.","The requested page rendering must be delayed until the global data has been fetched.","A unique loading spinner should be displayed to the user during this process, ensuring there's no flickering due to different spinners being rendered."]},{"l":"Fetch data","p":["\uD83D\uDC49 There are four key steps to fetch global public data:","Set the waitForPublicData prop of the AppRouter component to true.","Fetch the data using the usePublicDataQueries hook.","Use the useIsBootstrapping hook to display a loading spinner while the data is being retrieved.","Forward the data to the pages through a React context.","Here's an example:"]},{"i":"setup-the-msw-handler-used-in-the-example","l":":icon-file-code: Setup the MSW handler used in the example","p":["First, define an MSW request handler that returns the number of times it has been fetched:","Then, register the request handler using the module registration function:"]},{"i":"use-the-data-in-a-page","l":":icon-file-code: Use the data in a page"},{"l":"Handle fetch errors","p":["The usePublicDataQueries hook can throw GlobalDataQueriesError instances, which are typically unmanaged and should be handled by an error boundary. To assert in an error boundary that an error is an instance of GlobalDataQueriesError, use the isGlobalDataQueriesError function:"]},{"l":"Setup TanStack Query","p":["Fetching data with the usePublicDataQueries hook requires TanStack Query to be configured. To set it up, follow the Setup TanStack Query integration guide."]}],[{"l":"Fetch protected global data","p":["To make global protected data fetching easier, Squide provides primitives build on top of Tanstack Query to orchestrate both the data-loading states and the associated UI.","For more details, refer to the reference documentation."]},{"i":"the-challenges-with-global-data","l":":icon-light-bulb: The challenges with global data","p":["At first glance, one might wonder what could be so complicated about fetching the global data of an application. It's only fetches ...right? Well, there are several concerns to take into account for a modular application:","When in development, the global data cannot be fetched until the Mock Service Worker (MSW) request handlers are registered and MSW is ready.","To register the MSW request handlers, the modules must be registered first.","If the requested page is public, only the global public data should be fetched.","If the requested page is protected, both the global public and protected data should be fetched.","The requested page rendering must be delayed until the global data has been fetched.","A unique loading spinner should be displayed to the user during this process, ensuring there's no flickering due to different spinners being rendered."]},{"l":"Fetch data","p":["\uD83D\uDC49 There are four key steps to fetch global protected data:","Set the waitForProtectedData prop of the AppRouter component to true.","Fetch the data using the useProtectedDataQueries hook.","Use the useIsBootstrapping hook to display a loading spinner while the data is being retrieved.","Forward the data to the pages through a React context.","Here's an example:"]},{"i":"setup-the-msw-handler-used-in-the-example","l":":icon-file-code: Setup the MSW handler used in the example","p":["First, define an MSW request handler that returns the number of times it has been fetched:","Then, register the request handler using the module registration function:"]},{"i":"use-the-data-in-a-page","l":":icon-file-code: Use the data in a page"},{"l":"Handle fetch errors","p":["The useProtectedDataQueries hook can throw GlobalDataQueriesError instances, which are typically unmanaged and should be handled by an error boundary. To assert in an error boundary that an error is an instance of GlobalDataQueriesError, use the isGlobalDataQueriesError function:"]},{"l":"Setup TanStack Query","p":["Fetching data with the useProtectedDataQueries hook requires TanStack Query to be configured. To set it up, follow the Setup TanStack Query integration guide."]}],[{"l":"Fetch page data","p":["There are several approaches to fetching data for pages. We prefer using a backend-for-frontend (BFF) with a dedicated endpoint for each page, returning a data structure tailored to that page. We rely on server state as our single source and TanStack Query is used to handle data fetching and caching."]},{"l":"Fetch data","p":["\uD83D\uDC49 There are two key steps to fetch page data:","Fetch the data using the useSuspenseQuery hook.","Define a fallback element in the layout component using the Suspense component","Refer to the create a local module guide as a starting point and update both the module and its Page component to fetch data:"]},{"i":"setup-the-msw-handler-used-in-the-example","l":":icon-file-code: Setup the MSW handler used in the example","p":["First, define an MSW request handler that returns the number of times it has been fetched:","Then, register the request handler using the module registration function:"]},{"l":"Handle fetch errors","p":["Refer to the define error boundaries essential page."]},{"l":"Setup TanStack Query","p":["Refer to the setup TanStack Query integration guide."]}],[{"l":"Use the logger","p":["Squide integrates with the @workleap/logging library by accepting a loggers array during initialization. If no loggers are provided and the application is running in development mode, Squide automatically attaches a BrowserConsoleLogger instance to the runtime.","For more details, refer to the initializeFirefly and useLogger reference documentation."]},{"l":"Log a message","p":["To log a message, retrieve Squide logger instance throughout the application with the useLogger hook and write a log entry using any of the available methods:","For more information on how to use the logger, refer to the @workleap/logging package's documentation.","Never log any Personally Identifiable Information (PII).","API responses frequently contain sensitive user data such as names, email addresses, phone numbers, or IDs. Remove all logs outputting API response before deploying to production, as these can expose private information that will be included in session replays.","For debugging, use console.log instead, since its output is not captured in LogRocket session replays."]},{"l":"Setup loggers","p":["Refer to the setup the logger integration guide."]}],[{"l":"Use the event bus","p":["Squide provides a built-in event bus so that modules and other parts of a modular application can communicate in a loosely coupled way.","For more details, refer to the useEventBusListener and useEventBusDispatcher reference documentation."]},{"l":"Add an event listener","p":["Register a function that will be invoked each time the specified event is dispatched:"]},{"l":"Add an event listener that will be invoked once","p":["Register a function that will be invoked once, and then automatically unregisters itself:"]},{"l":"Dispatch an event"}],[{"l":"Use environment variables","p":["Environment variables are incredibly useful when working with multiple environments, such as dev, staging, and production because they decouple configuration from code. This allows to change an application's behavior without modifying the code itself. A common example is the URLs of dedicated API services, where each environment uses a different URL.","By attaching environment variables to a FireflyRuntime instance, rather than accessing process.env throughout the codebase, Squide supports a modular architecture and makes it easier to write tests and Storybook stories by isolating configuration from global state.","For more details, refer to the reference documentation."]},{"i":"why-is-using-processenv-problematic","l":":icon-light-bulb: Why is using `process.env` problematic?","p":["While accessing environment variables through process.env works, it comes with several drawbacks:","Not ideal for testing: Mocking process.env for testing is cumbersome because it is a global variable. This often results in flaky tests, poor isolation, and unexpected side effects.","Not ideal for stories: Mocking process.env in Storybook stories can also be cumbersome.","Not ideal for modular code: Modules that rely on global variables are harder to load independently, reuse, or run in different host applications. This goes against modular design principles.","Couples the code to Node.js: Many environments do not support process.env, including browsers, Web Workers, Service Workers, Cloudflare Workers, Vercel Edge Functions, Netlify Edge Functions, and Deno (unless running in Node-compatibility mode)."]},{"l":"Register variables at initialization","p":["If some environment variables are already available at startup, they can be provided directly when initializing Squide:"]},{"l":"Register a variable","p":["An environment variable with the same key can be registered multiple times (e.g., by multiple modules) as long as the value remains the same. If the value differs, an Error will be thrown."]},{"l":"Register multiple variables at once"},{"l":"Retrieve a single variable","p":["Using the useEnvironmentVariable hook:","Using the runtime instance:"]},{"l":"Retrieve all the variables","p":["Using the useEnvironmentVariables hook:","Using the runtime instance:"]},{"l":"Setup the typings","p":["Before registering variables, modules must augment the EnvironmentVariables interface with the variables they intend to register to ensure type safety and autocompletion.","First, create a types folder in the project:","Then create an env-vars.d.ts file:","Finally, update the project tsconfig.json to include the types folder:","If any other project using those environment variables must also reference the project's env-vars.d.ts file:"]},{"l":"Setup with tests","p":["If the code under test uses environment variables, the FireflyRuntime instance can be used to mock these variables.","Considering the following utility hook:","The following unit test can be written to mock the value of apiBaseUrl and test the ouput of the useAbsoluteUrl hook:"]},{"l":"Setup with Storybook","p":["Components included in Storybook stories often rely on environment variables. The EnvironmentVariablesPlugin instance can be used to mock these variables:"]}],[{"l":"Set Honeycomb custom attributes","p":["For Honeycomb traces to be useful, most application needs to set information about the current user environment on monitoring and performance traces. To help with that, Squide can integrate with the setGlobalSpanAttributes method of the HoneycombInstrumentationClient.","To set information retrieved from the global data as custom attributes on Honeycomb traces, refer to the fetch protected global data essential page as a starting point and update the BootstrappingRoute component to retrieve the Honeycomb client instance and set the attributes:","Now, every trace recorded after the session initialization will include the custom attributes app.user_id:","Custom attributes"]}],[{"l":"Localize resources","p":["To localize resources for a Squide application, start by following the setup i18next integration guide to configure the i118nextPlugin and create and register an i18next instance for your module. Once the setup is complete, the examples below cover the most common use cases.","For more detail, refer to the i18next reference documentation."]},{"l":"Localize a page resource","p":["To localize a resource within a page, first retrieve the module's i18next instance using the useI18nextInstance hook. Then, use that instance with i18next native useTranslation hook to access the translated resources:"]},{"i":"localized-resource-files","l":":icon-file-code: Localized resource files"},{"l":"Localize a navigation item label","p":["A navigation item can be localized by combining the $label option with the I18nextNavigationItemLabel component:"]},{"i":"localized-resource-files","l":":icon-file-code: Localized resource files"},{"l":"Use the Trans component","p":["The Trans component is useful for scenarios involving interpolation to render a localized resources. To use the Trans component with Squide, pair it with an i18next instance retrieved from useI18nextInstance hook:","The Trans component can also be used without the t function by including a namespace to the i18nKey property value:"]}],[{"l":"Register plugins","p":["To keep Squide lightweight, not all functionalities should be integrated as a core functionality. However, to accommodate a broad range of technologies, a plugin system has been implemented to fill the gap."]},{"l":"Register a plugin","p":["Plugins can be registered at bootstrapping with the initializeFirefly function:"]},{"l":"Retrieve a plugin","p":["Using the usePlugin hook:","Using the runtime instance:"]}],[{"l":"Define error boundaries","p":["Squide uses React Router's error boundary system to isolate failures when possible and to catch unhandled errors. This page explains how Squide integrates with React Router's error boundaries and how to define them at different levels of your application."]},{"l":"Handle unmanaged errors","p":["Every application should at least define a root error boundary. It acts as the final safety net, catching any unhandled errors that escape the rest of the application.","To create a root error boundary, refer to the register the root layout section of the create an host application guide and wrap the RootLayout in a pathless route that defines an errorElement property:"]},{"i":"root-error-boundary-example","l":":icon-file-code: Root error boundary example"},{"l":"Handle module errors","p":["A failure in a single module can potentially break the entire application. To isolate module-level errors, refer to the register the root layout section of the create an host application guide as a starting point and wrap the PublicRoutes and ProtectedRouter placeholders in a pathless route that provides an errorElement property:"]},{"i":"module-error-boundary-example","l":":icon-file-code: Module error boundary example"},{"i":"similarities-with-iframe-based-architectures","l":":icon-light-bulb: Similarities with iframe-based architectures","p":["One of the key characteristics of a modular implementation such as iframes is the ability to isolate failures within individual iframe, preventing them from breaking the entire application.","However, this characteristic is not inherent to a standard Squide implementation as all the modules share the same browsing context (e.g. the same Document object, the same Window object, and the same DOM). A failure in one module can potentially breaks the entire application.","That said, a Squide application can achieve near-iframe-level failure isolation by leveraging React Router's Outlet along with the errorElement property of a React Router's routes. This approach allows individual routes (and their associated modules) to handle errors gracefully, preventing them from cascading and affecting the rest of the app."]},{"l":"Handle route errors","p":["While we don't recommend defining an error boundary for every route, there are cases where it makes sense to catch errors within a specific route or any of its descendants, rather than letting a failure crash an entire module, or even the whole application.","To define an error boundary for a specific route and its descendants, add an errorElement property to the route definition:"]},{"i":"route-error-boundary-example","l":":icon-file-code: Route error boundary example"},{"l":"Not found page","p":["A no-match route can be defined to catch invalid or unknown URLs. To do this, register a route with * as the path:"]}],[{"l":"Create an host application","p":["We highly recommend going through the entire getting started guide. However, if you prefer to scaffold the application we'll be building, a template is available with degit:","Let's begin by creating the application that will serve as the entry point for our federated application and host the application modules."]},{"l":"Install the packages","p":["Create a new application (we'll refer to ours as host), then open a terminal at the root of the new solution and install the following packages:"]},{"l":"Setup the application","p":["First, create the following files:","Then, ensure that you are developing your application using ESM syntax by specifying type: module in your package.json file:","Finally, use a dynamic import to add an async boundary:","To learn more about this async boundary and the bootstrap.tsx file, read the following article."]},{"l":"Module registration","p":["Next, to register the modules, instanciate a shell FireflyRuntime instance and register the remote module with the initializeFirefly function (the configuration of the remote module will be covered in the next section):","Then, render the AppRouter component to define a React Router browser instance configured with the registered routes:"]},{"l":"Navigation items","p":["Next, create a layout component to render the navigation items. In many applications, multiple pages often share a common layout that includes elements such as a navigation bar, a user profile menu, and a main content section. In a React Router application, this shared layout is commonly referred to as a RootLayout:","The RootLayout component created in the previous sample will serves as the default layout for the homepage as well as for every page (route) registered by a module that are not nested under a parent route with either the parentPath or the parentId option."]},{"l":"Homepage","p":["Next, create the HomePage component that will serve as the homepage:","Then, add a local module at the root of the host application to register the homepage:","And an hoisted route to render the RootLayout with the PublicRoutes and ProtectedRoutes placeholders:","The PublicRoutes and ProtectedRoutes placeholders indicates where routes that are neither hoisted or nested with a parentPath or parentId option will be rendered. In this example, the homepage route is considered as a protected route and will be rendered under the ProtectedRoutes placeholder.","Finally, update the bootstrapping code to register the newly created local module:"]},{"l":"Not found page (404)","p":["Now, let's ensure that users who enter a wrong URL end up somewhere by registering a custom no-match route. First, create the NotFoundPage component, which will serve as the page for handling not found routes:","Then, register the newly created component as the * route:"]},{"l":"Configure webpack","p":["Squide webpack configuration is built on top of @workleap/webpack-configs, @workleap/browserslist-config and @workleap/swc-configs. If you are having issues with the configuration of these tools, refer to the tools documentation websites.","First, open the public/index.html file created at the beginning of this guide and copy/paste the following HtmlWebpackPlugin template:","Then, open the .browserslist file and copy/paste the following content:"]},{"l":"Development configuration","p":["To configure webpack for a development environment, first open the swc.dev.js file and copy/paste the following code:","Then, open the webpack.dev.js file and use the defineDevHostConfig function to configure webpack:","If you are having issues with the wepack configuration that are not related to module federation, refer to the @workleap/webpack-configs documentation.","If the application does not not include any remote modules, use the defineDevConfig function instead of defineDevHostConfig."]},{"l":"Build configuration","p":["To configure webpack for a build environment, first open the swc.build.js file and copy/paste the following code:","Then, open the webpack.build.js file and use the defineBuildHostConfig function to configure webpack:","If you are having issues with the wepack configuration that are not related to module federation, refer to the @workleap/webpack-configs documentation.","If the application does not not include any remote modules, use the defineBuildConfig function instead of defineBuildHostConfig."]},{"l":"Add CLI scripts","p":["To initiate the development server, add the following script to the application package.json file:","To build the application, add the following script to the application package.json file:"]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the application in a development environment using the dev script. You should see the homepage. Even if the remote module application is not yet available, the host application will gracefully (and ignore the remote module)."]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this guide:","Open the DevTools console. You'll find a log entry for each registration that occurs and error messages if something went wrong:","[squide] Found 1 local module to register.","[squide] 1/1 Registering local module.","[squide] 1/1 Local module registration completed.","[squide] Found 1 remote module to register.","[squide] 1/1 Loading module register of remote1.","[squide] 1/1 Registering module register of remote remote1.","[squide] 1/1 The registration of the remote remote1 is completed.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Create a remote module","p":["We highly recommend going through the entire getting started guide. However, if you prefer to scaffold the application we'll be building, a template is available with degit:","Remote modules are modules that are not included in the host application build but are instead loaded at runtime from a remote server. They provide a way for teams to be fully autonomous by independently deploying their modules without relying on the other parts of the application.","Let's add our first remote module!"]},{"l":"Install the packages","p":["Create a new application (we'll refer to ours as remote-module), then open a terminal at the root of the new solution and install the following packages:"]},{"l":"Setup the application","p":["First, create the following files:","Then, ensure that you are developing your module using ESM syntax by specifying type: module in your package.json file:"]},{"l":"Routes registration","p":["Next, register the remote module routes and navigation items with the registerRoute and registerNavigationItem functions:","Then, create the Page component:"]},{"l":"Configure webpack","p":["Squide webpack configuration is built on top of @workleap/webpack-configs, @workleap/browserslist-config and @workleap/swc-configs. If you are having issues with the configuration of these tools, refer to the tools documentation websites."]},{"l":"Development configuration","p":["To configure webpack for a development environment, first open the swc.dev.js file and copy/paste the following code:","Then, open the webpack.dev.js file and use the defineDevRemoteModuleConfig function to configure webpack:","If you are having issues with the wepack configuration that are not related to module federation, refer to the @workleap/webpack-configs documentation."]},{"l":"Build configuration","p":["To configure webpack for a build environment, first open the swc.build.js file and copy/paste the following code:","Then, open the webpack.build.js file and use the defineBuildRemoteModuleConfig function to configure webpack:","If you are having issues with the wepack configuration that are not related to module federation, refer to the @workleap/webpack-configs documentation."]},{"l":"Add CLI scripts","p":["To initiate the development server, add the following script to the application package.json file:","To build the module, add the following script to the application package.json file:"]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the host and the remote-module applications in development mode using the dev script. You should notice an additional link labelled Remote/Page in the navigation menu. Click on the link to navigate to the page of your new remote module!"]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this guide:","Open the DevTools console. You'll find a log entry for each registration that occurs and error messages if something went wrong:","[squide] The following route has been registered.","[squide] The following static navigation item has been registered to the root menu for a total of 2 static items.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Add a shared dependency","p":["Shared dependencies is one of the most powerful concepts of Module Federation. However, mastering its configuration can be quite challenging. Failure to configure shared dependencies properly in a federated application using Module Federation can significantly impact both user and developer experiences.","Squide aims to simplify the configuration of shared dependencies by abstracting the shared dependencies necessary for building an application with React, React Router, and optionally MSW and i18next. Nevertheless, every federated application will inevitably have to configure additional custom shared dependencies.","For a comprehensive documentation of the Module Federation APIs, their functionality, and their benefits, please refer to this article."]},{"l":"Understanding singleton dependencies","p":["A singleton shared dependency does exactly what its name suggests: it loads a single instance of a dependency. This means that a dependency will be included in just one bundle file of the federated application."]},{"l":"Strict versioning","p":["Sometimes, a singleton shared dependency is paired with the strictVersion option:","When specified, the strictVersion option will generate a runtime error if a module attempts to load a version of the dependency that is incompatible with the specified version. It's often unnecessary to use a strict version, and omitting it provides greater flexibility when it comes time to update the shared dependency version."]},{"l":"Expected behaviors","p":["Please note that Squide's singleton dependency version resolution algorithm differs from the native Module Federation behavior. By default, Squide registers a runtime plugin that customize the resolution of shared dependencies."]},{"l":"Minor or patch version","p":["When the version difference between a host application and a remote module is a minor or patch version, the higher version of the dependency will be loaded. For example:","If the host application is on 10.1.0 and a remote module is on 10.1.1-> 10.1.1 will be loaded","If the host application is on 10.1.0 and a remote module is on 10.2.0-> 10.2.0 will be loaded"]},{"l":"Major version","p":["If the version difference between a host application and a remote module is a major version, once again, the higher version of the dependency will be loaded only if it's requested by the host application. For example:","If the host application is on 11.0.0 and a remote module is on 10.0.0-> 11.0.0 will be loaded","If the host application is on 10.0.0 and a remote module is on 11.0.0-> 10.0.0 will be loaded"]},{"l":"Additional examples","p":["Let's go through a few additional examples \uD83D\uDC47"]},{"l":"Example 1","p":["The version requested by remote-1 is selected because it only represents a minor difference from the version requested by the host application."]},{"l":"Example 2","p":["The version requested by the host application is selected because remote-1 is requesting a version with a major difference from the one requested by the host application."]},{"l":"Example 3","p":["The version requested by remote-2 is selected because remote-1 is requesting a version with a major difference from the one requested by the host application. Therefore, remote-2 requests the next highest version, which represents only a minor difference from the version requested by the host application."]},{"l":"What should be configured as a shared dependency?","p":["Libraries matching the following criterias are strong candidates to be configured as shared dependencies:","Medium to large libraries that are used by multiple modules.","Libraries that requires a single instance to work properly (like react).","Libraries exporting React contexts."]},{"l":"Understanding eager dependencies","p":["An eager shared dependency becomes available as soon as the host application starts. In simple terms, it is included in the host application bundle rather than being loaded lazily when it is first requested.","The key point to remember about eager dependencies is that only one application or remote module should configure a shared dependency as eager. Otherwise, the dependency will be included in the bundle of the host application and of every remote module that set the dependency as eager."]},{"l":"What should be configured as an eager dependency?","p":["Any shared dependency that must be loaded to bootstrap the application."]},{"l":"Default shared dependencies","p":["Since Squide has dependencies on React and React Router, the define* functions automatically configure shared dependencies for these packages by default, in addition to Squide own packages. The following shared dependencies are set as eager singleton by default:","react","react-dom","react-router","@squide/core","@squide/react-router","@squide/module-federation","@squide/msw","@squide/env-vars","@opentelemetry/api","For the full shared dependencies configuration, have a look at the defineConfig.ts file on Github.","You can extend or override the default shared dependencies configuration."]},{"l":"Add custom shared dependencies","p":["To configure shared dependencies, use the sharedDependencies option of any define* function:","When a dependency is shared between a host application and a remote module, the sharing options must be configured on both ends:"]},{"l":"React context limitations","p":["For a React context to be provided by the host application and consumed by the remote modules, the library exporting the React context must be set as a singleton.","To troubleshoot a React context issue or find more information about the limitations, refer to the troubleshooting page."]},{"l":"React dependencies requirements","p":["react and react-dom dependencies must be configured as a singleton, otherwise either an error will be thrown at bootstrapping if the loaded react versions are incompatible, or features like useState will not work.","The react-router dependency must as well be configured as a singleton because it relies on a global React context that needs to be declared in the host application and is consumed by remote modules."]},{"l":"Learn more","p":["To learn more about Module Federation shared dependencies read this article about the shared APIs and refer to this POC on GitHub."]}],[{"l":"Develop a module in isolation","p":["To develop their own independent module, a team should not need to install the host application or any other modules of the application they do not own. However, they should have a way to integrate their module with the application shell (e.g., RootLayout, RootErrorBoundary, etc..) while working in isolation.","To achieve this, the first step is to extract the application shell from the host application. There are various ways to accomplish this, but in this guide, we'll transform the host application into a monorepo and introduce a new local package named @sample/shell specifically for this purpose:"]},{"l":"Create a shell package","p":["The implementation details of the RootLayout, RootErrorBoundary and ModuleErrorBoundary components won't be covered by this guide as it already has been covered many times by other guides.","For additional information refer to the create an host app and define error boundaries guides.","First, create a new package (we'll refer to ours as shell) and add the following fields to the package.json file:","Then, install the package dependencies and create an AppRouter component in the shell package to provide a reusable router configuration that can be shared between the host application and the isolated modules. This new AppRouter component should wrap the @squide/firefly AppRouter component:","Finally, create a local module to register the application shell. This module will be used by both the host application and the isolated modules:","This guide only covers the RootLayout, RootErrorBoundary and ModuleErrorBoundary components but the same goes for other shell assets such as an AuthenticationBoundary component."]},{"l":"Update the host application","p":["Now, let's revisit the host application by adding the new @sample/shell package as a dependency:","Then, integrate the AppRouter component from the @sample/shell package into the application:","And finally include the registerShell function to setup the RootLayout and RootErrorBoundary components as well as any other shell assets:"]},{"l":"Setup a remote module","p":["With the new shell package in place, we can now configure the remote module to be developed in isolation. The goal is to start the module development server and render the module pages with the same layout and shared functionalities as if it was rendered by the host application.","To begin, let's start by adding a dependency to the @sample/shell package:","Then, create the following files in the remote module application:"]},{"l":"index.tsx","p":["The index.tsx file is similar to the bootstrap.tsx file of an host application but, tailored for an isolated module. The key distinctions are that all the modules are registered as local modules, and a new registerDev function is introduced to register the development homepage (which will be covered in an upcoming section):"]},{"l":"App.tsx","p":["The App.tsx file uses the newly created AppRouter component to setup Squide's primitives with a React Router instance:"]},{"l":"DevHome.tsx","p":["The DevHome component is the homepage when the remote module is developed in isolation:","To register the development homepage, create a new local module specifically for configuring the remote during isolated development:"]},{"l":"Add a new CLI script","p":["Next, add a new dev-isolated script to the package.json file to start the local development server in isolation:","If your project's package.json file does not already include the cross-env dependency, be sure to install cross-env as a development dependency.","The dev-isolated script is similar to the dev script but introduces an ISOLATED environment variable. This variable will be used by the webpack.dev.js file to conditionally configure the development server to either serve the module as an application for isolated development or as a remote endpoint by the host application through the /remoteEntry.js entry point."]},{"l":"Configure webpack","p":["First, open the public/index.html file created at the beginning of this guide and copy/paste the following HtmlWebpackPlugin template:","Then, open the .browserslist file and copy/paste the following content:"]},{"l":"Isolated environment configuration","p":["To configure webpack, open the webpack.dev.js file and update the configuration to incorporate the ISOLATED environment variable and the defineDevHostConfig function:","If you encounter issues configuring webpack, refer to the @workleap/webpack-configs documentation."]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the remote module in isolation by running the dev-isolated script. The application shell should wrap the pages of the module and the default page should be DevHome."]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this section of the guide:","Open the DevTools console. You'll find a log entry for each registration that occurs and error messages if something went wrong.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Setup i18next","p":["Most Workleap's application are either already bilingual or will be in the future. To help feature teams deal with localized resources, Squide provides a native plugin designed to adapt the i18next library for modular applications.","The examples in this guide load all the resources from single localized resources files. For a real Workleap application, you probably want to spread the resources into multiple files and load the files with a i18next backend plugin."]},{"l":"Setup the host application","p":["Let's start by configuring the host application. First, open a terminal at the root of the host application and install the following packages:"]},{"l":"Register the i18nextPlugin","p":["Then, update the host application boostrapping code to register an instance of the i18nextplugin with the FireflyRuntime instance:","In the previous code sample, upon creating an i18nextPlugin instance, the user language is automatically detected using the plugin.detectUserLanguage function. Applications should always detect the user language at bootstrapping, even if the current language is expected to be overriden by a preferred language setting once the user session has been loaded."]},{"l":"Define the localized resources","p":["Next, create the localized resource files for the en-US and fr-CA locales:"]},{"l":"Register an i18next instance","p":["Then, update the host application local module's register function to create and register an i18next instance with the retrieved i18nextPlugin instance. Due to how the internals of i18next works, each module (including the host application) must create its own instance of the third-party library. i18nextPlugin will handle synchronizing the language changes across all i18next instances:","In the previous code sample, notice that the i18next instance has been initialized with the current language of the i18nextPlugin instance by providing the lng option. If the user language has been detected during bootstrapping, the i18next instance will then be initialized with the user language which has been deduced from either a ?language querystring parameter or the user navigator language settings. Otherwise, the application instance will be initialized with the fallback language, which is en-US for this guide."]},{"l":"Localize the home page resources","p":["Then, update the HomePage component to use the newly created localized resource:"]},{"l":"Setup a remote module","p":["First, open a terminal at the root of the remote module application and install the following packages:"]},{"i":"define-the-localized-resources-1","l":"Define the localized resources","p":["Then, create the localized resource files for the en-US and fr-CA locales:","Notice that this time, a standard navigationItems namespace has been added to the resource files. The resources in the navigationItems namespace will be used later on to localize the navigation items labels."]},{"i":"register-an-i18next-instance-1","l":"Register an i18next instance","p":["Then, update the remote module's register function to create and register an instance of i18next with the i18nextPlugin plugin instance. Similarly to the host application, due to how the internals of i18next works, this local module requires to register its own instance of the third-party library:"]},{"l":"Localize the navigation item labels","p":["Then, localize the navigation items labels using the I18nextNavigationItemLabel component. Since this example resources are in the navigationItems namespace, there's no need to specify a namespace property on the components as it will be inferred:"]},{"l":"Localize the page resources","p":["Then, update the Page component to use the newly created localized resource:"]},{"l":"Update the webpack configurations","p":["Finally, update the webpack development and build configurations to activate the i18next feature. Enabling this feature will configure the i18next libraries as shared dependencies:"]},{"l":"Integrate a backend language setting","p":["Refer to the integrate a backend language setting section of the setup i18next integration guide."]},{"l":"Use the Trans component","p":["Refer to the use the Trans component section of the localize resources page."]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the application in a development environment using the dev script. The homepage and the navigation items should render the english ( en-US) resources. Then append ?language=fr-CA to the URL. The homepage and the navigation items should now render the french ( fr-CA) resources."]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this guide:","Open the DevTools console. You'll find a log entry for each i18next instance that is being registered and another log everytime the language is changed:","[squide] Registered a new i18next instance with key remote-module.","[squide] The language has been changed to fr-CA.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Override a React context","p":["In a modular application, it's typical to configure various global React context at the root of the host application. These contexts are then used by the layouts and pages of the modules.","Let's explore a simple example using a BackgroundColorContext:","In the previous code samples, the host application provides a value for the BackgroundColorContext, and the ColoredPage component of the remote module uses this value to set its background color (to blue for this example)."]},{"l":"Override the context for the module","p":["Now, suppose the requirements change, and a page of the remote module must have a red background. The context can be overriden for that page by declaring a new provider directly in the routes registration:"]},{"l":"Extract an utility component","p":["Since there are multiple routes to setup with the new provider, an utility component can be extracted:"]},{"l":"Update a singleton dependency version","p":["This section only applies to federated applications (applications including remote modules).","Let's consider a more specific use case where the host application declares a ThemeContext from Workleap's new design system, Hopper:","In this scenario, Hopper's components are used throughout the entire application, including the modules. Moreover, @hopper/components is defined as a singleton shared dependency:","Now, consider a situation where Hopper releases a new version of the package that includes breaking changes, without a \"compatibility\" package to ensure backward compatility with the previous version.","To update the host application without breaking the modules, we recommend to temporary \"break\" the singleton shared dependency by loading two versions of the @hopper/components dependency in parallel (one for the host application and one for the modules that have not been updated yet):","As @hopper/components expose the ThemeContext, the context must be re-declared in each module until every part of the federated application has been updated to the latest version of @hopper/components:","Thankfully, React Router makes it very easy to declare contexts in a module."]}],[{"l":"Recipes","p":["Add authentication","Override the host layout","Use modular tabs"]}],[{"l":"Add authentication","p":["Before going forward with this recipe, make sure that you complete the Setup MSW and Fetch global protected data guides.","Most of Workleap's applications, if not all, will eventually require user authentication. While Squide doesn't offer built-in primitives for this process, it can assist by providing a well-established recipe to integrate an authentication flow with Squide."]},{"l":"Add a login page","p":["First, open a terminal at the root of the host application and install the @squide/fakes package:","Then, add a Mock Service Worker(MSW) request handler to authenticate a user:","In the previous code sample, the endpoint attempts to authenticate the provided credentials against existing users. If there's a match, the user session is stored in the local storage using a LocalStorageSessionManager instance, and a 200 status code is returned.","Our security department reminds you to refrain from using a fake LocalStorageSessionManager in a production application \uD83D\uDE0A","Next, register the request handler using the host application module registration function:","Then, create a login page:","After the user logs in, the application is reloaded, this is a requirement of the AppRouter component. Nevertheless, it's not a concern because Workleap's applications use a third-party service for authentication which requires a full refresh of the application."]},{"l":"Create a session manager","p":["Next, create a shared type for the session and the session manager:","Then, create a shared SessionManagerContext along with some utility hooks. This React context will be used to share the SessionManager instance down the components tree:","Finally, let's go back to the host application and create a TanStack Query implementation of the shared SessionManager interface created previously:"]},{"l":"Fetch the session","p":["Next, create an MSW request handler that returns a session object if a user is authenticated:","Then, update the host application App component to load the session with the useProtectedDataQueries hook and create an instance of TanstackQuerySessionManager with the retrieved session to share the sessuib via the SessionManagerContext:","The previous example uses the following implementation of the ApiError class:"]},{"l":"Add an authentication boundary","p":["Next, create an authentication boundary component using the shared useIsAuthenticated hook created earlier to redirect unauthenticated user to the login page:"]},{"l":"Define an authenticated layout","p":["Now, let's add a specific layout for authenticated users that passes through the AuthenticationBoundary component.","First, add a MSW request handler to log out a user:","Then, introduce a new AuthenticatedLayout component displaying the name of the logged-in user along with a logout button. This layout will retrieve the active user session from the shared useSessionManager hook introduced earlier:","By creating a new AuthenticatedLayout component, much of the layout code has been transferred from the RootLayout to the AuthenticatedLayout, leaving the root layout responsible only for styling the outer wrapper of the application for now:"]},{"l":"Setup the routes","p":["Finally, assemble everything:"]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the application using the dev script and attempt navigating to the root page (/). You will be redirected to the /login page. Login with temp/ temp, you will be redirected to the root page."]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this guide:","Open the DevTools console. You'll find a log entry for each registration that occurs and error messages if something went wrong.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Override the host layout","p":["The RootLayout component defined in the create an host app starting guide serves as the default layout for the homepage and all the managed routes.","For most routes, this behavior is what the author expects. However, as an application introduces authentication and adds many session-related features to the default layout, this default layout may no longer be suitable for every route. For example, a login page doesn't require session-related features, as the user isn't authenticated yet. In such cases, the default layout isn't appropriate.","To accomodate pages requiring a different layout, a mechanism is needed to move their route declaration to the root of the React Router instance before RootLayout is declared."]},{"l":"Hoist a module routes","p":["Package managers supporting workspaces such as Yarn and NPM call this mechanism \"hoisting\", which means \"raise (something) by means of ropes and pulleys\". This is exactly what we are trying to achieve here.","Squide has a built-in hoist functionality capable of raising module routes marked as hoist at the root of the routes array, before the RootLayout declaration. Thus, an hoisted route will not be wrapped by the RootLayout component (or any authentication boundaries) and will have full control over its rendering.","To hoist module routes, add the hoist option to the route registration options and optionally use a different layout:","By declaring a route as hoisted, other parts of the application will not be isolated anymore from this route's failures as the route will most likely be rendered outside of the host application's root error boundary. To avoid breaking the entire application when an hoisted route encounters unhandled errors, it is highly recommended to declare a React Router's errorElement property for each hoisted routes.","By declaring a route as hoisted, the route will be rendered at the root of the router, therefore, most certainly outside the authenticated boundary of the application. If the hoisted route requires an authentication, make sure to wrap the route with an authentication boundary or to handle the authentication within the route's page."]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the application in a development environment using the dev script and navigate to the /login page. The page should be displayed even if you are not authenticated."]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this guide:","Open the DevTools console. You'll find a log entry for each registration that occurs and error messages if something went wrong.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Use modular tabs","p":["While it's typically recommended for a Squide application to maintain the boundary of a page within a single domain, there are situations where enhancing the user experience necessitates rendering a page with parts from multiple domains, or at the very least, simulating it \uD83D\uDE0A.","For this guide, we'll take as an example a page for which the parts that are owned by different domains are organized by tabs (modular tabs) and registered by different modules:","Tab 1: Registered by Local Module 1","Tab 2: Registered by Local Module 2","Tab 3: Registered by Local Module 3","Anatomy of a page rendering modular tabs"]},{"l":"Define a nested layout","p":["To build this page while adhering to Squide's constraint of avoiding hard references to elements from other modules, let's start by defining a React Router nested layout. This nested layout will handle rendering all the tab headers and the content of the active tab:","In the previous code sample, the TabsLayout component is similar to the RootLayout component introduced in previous guides. However, the key distinction is that this layout will be bound to the /tabs URL path. By nesting the layout under a specific path, it will only render when the user navigates to one of the modular tab pages (e.g. /tabs, /tabs/tab-1, /tabs/tab-2, /tabs/tab-3).","To register the newly created layout as a nested layout, use the registerRoute function:","With this nested layout in place, thanks to the React Router Outlet component, the content of the tabs can now reside in distinct routes(registered by different modules) while still delivering a cohesive user experience. Whenever a user navigates between the tabs, the URL will be updated, and the tab content will change, but the shared portion of the layout will remain consistent.","As a bonus, each individual tab will have its own dedicated URL! \uD83E\uDD73"]},{"l":"Create the tab routes","p":["Next, let's add the actual tabs to the modules. To do so, we'll use the parentPath option of the registerRoute function to register the routes under the TabsLayout component:","Now that the tabs has been registered, ensure that all four modules are registered in the host application. Start the development servers using the dev script. Navigate to the /tabs page, you should see the tab headers. Click on each tab header to confirm that the content renders correctly."]},{"l":"Decouple the navigation items","p":["Althought it's functional, the modules are currently coupled by hardcoded URLs within the TabsLayout component.","To decouple the navigation items, similar to what is done for regular module's routes, we'll use the registerNavigationItem function. In this case, we'll specify a menuId option. Defining the menuId option will allow the TabsLayout component to exclusively retrieve the navigation items that belongs to him.","First, let's register the navigation items with the menuId option. For this example the menuId will be /tabs(it can be anything):","Then, update the TabsLayout component to render the registered navigation items instead of the hardcoded URLs:"]},{"l":"Change the display order of the tabs","p":["Similarly to how the display order of regular navigation items can be configured, a modular tab position can be affected with the priority option.","To force Tab 3 to be positioned first, we'll give him a priority of 999:"]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["To ensure everything is still working correctly, start the development servers using the dev script and navigate to the /tabs page. You should see all three tabs, and you should be able to switch between them by clicking on the tab headers."]},{"l":"Troubleshoot issues","p":["If you are experiencing issues with this guide:","Open the DevTools console. You'll find a log entry for each registration that occurs and error messages if something went wrong:","[squide] The following route has been registered as a children of the /tabs route.","[squide] The following static navigation item has been registered to the /tabs menu for a total of 1 item.","Refer to a working example on GitHub.","Refer to the troubleshooting page."]}],[{"l":"Reference"},{"l":"Artefacts","p":["Packages"]},{"l":"API"},{"l":"Runtime","p":["FireflyRuntime class","FireflyProvider","useRuntime","useRuntimeMode"]},{"l":"Registration","p":["initializeFirefly","useDeferredRegistrations","mergeDeferredRegistrations"]},{"l":"Routing","p":["AppRouter","PublicRoutes","ProtectedRoutes","useIsBoostrapping","useRoutes","useRouteMatch","useIsRouteProtected","resolveRouteSegments","useRenderedNavigationItems","useNavigationItems","isNavigationLink"]},{"l":"Messaging","p":["useEventBusDispatcher","useEventBusListener"]},{"l":"Global data fetching","p":["usePublicDataQueries","useProtectedDataQueries","usePublicDataHandler","useProtectedDataHandler","isGlobalDataQueriesError"]},{"l":"Mock Service Worker","p":["MswPlugin"]},{"l":"i18next","p":["i18nextPlugin","getI18nextPlugin","useChangeLanguage","useCurrentLanguage","useI18nextInstance","I18nextNavigationItemLabel"]},{"l":"Environment variables","p":["EnvironmentVariablesPlugin","EnvironmentVariables","useEnvironmentVariable","useEnvironmentVariables"]},{"l":"Logging","p":["useLogger"]},{"l":"Plugins","p":["Plugin","usePlugin"]},{"l":"Fakes","p":["LocalStorageSessionManager","ReadonlySessionLocalStorage"]},{"l":"Storybook","p":["initializeFireflyForStorybook","withFireflyDecorator","FireflyDecorator"]},{"l":"Module Federation","p":["initializeFirefly"]},{"l":"webpack","p":["defineDevHostConfig","defineDevRemoteModuleConfig","defineBuildHostConfig","defineBuildRemoteModuleConfig"]},{"l":"Rsbuild","p":["defineDevHostConfig","defineDevRemoteModuleConfig","defineBuildHostConfig","defineBuildRemoteModuleConfig"]}],[{"l":"Packages","p":["@squide/core","@squide/env-vars","@squide/fakes","@squide/firefly","@squide/firefly-module-federation","@squide/firefly-rsbuild-configs","@squide/firefly-rsbuild-storybook","@squide/firefly-webpack-configs","@squide/i18next","@squide/msw","@squide/react-router","A collection of fake implementations, facilitating the development of modular applications.","Add support for environment variables.","Add support for i18next.","Add support for Module Federation.","Add support for MSW.","Add support for Storybook.","Core functionalities of Squide.","Description","Name","NPM","npm version","Rsbuild configuration helpers for the Squide firefly technology stack.","Specific implementation of the core functionalities to support React Router.","Squide bundle for the firefly technology stack.","webpack configuration helpers for the Squide firefly technology stack."]}],[{"l":"FireflyRuntime","p":["Don't instanciate your own instance of FireflyRuntime, use the initializeFirefly function instead.","A runtime instance give modules access to functionalities such as routing, navigation, request handlers and logging."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","mode: An optional mode to optimize Squide for production. Values are development(default) and production.","honeycombInstrumentationClient: An optional Honeycomb instrumentation client for tracing the Squide bootstrapping flow.","loggers: An optional array of Logger instances.","plugins: An optional array of Plugin factory functions."]},{"l":"Methods","p":["registerRoute(route, options?): Register a route.","registerNavigationItem(navigationItem, options?): Register a navigation item.","getNavigationItems(menuId?): Retrieve the registered navigation items.","registerRequestHandlers(handlers): Register the MSW request handlers.","getEnvironmentVariable(key): Retrieve an environment variable.","getEnvironmentVariables(): Retrieve all environment variables.","registerEnvironmentVariable(key, value): Register a single environment variable.","registerEnvironmentVariables(variables): Register multiple environment variables.","getPlugin(name): Retrieve the registered plugin by the specified name."]},{"l":"Getters","p":["mode: Retrieve the runtime mode.","routes: Retrieve the registered routes.","requestHandlers: Retrieve the registered MSW request handlers.","isMswEnabled: Indicate whether or not MSW is enabled.","logger: Retrieve the runtime logger.","eventBus: Retrieve the runtime event bus.","plugins: Retrieve the registered plugins."]},{"l":"Usage"},{"l":"Create a runtime instance"},{"l":"Change the runtime mode"},{"l":"Register routes","p":["route: accept any properties of a React Router Route component with the addition of:","$id: An optional identifier for the route. Usually used to nest routes under a specific route.","$visibility: An optional visibility indicator for the route. Accepted values are public or protected.","options: An optional object literal of options:","hoist: An optional boolean value to register the route at the root of the router. The default value is false.","parentPath: An optional path of a parent route to register this new route under.","parentId: An optional id of a parent route to register this new route under."]},{"l":"Register an hoisted route","p":["Unlike a regular route, a hoisted route is added at the root of the router, outside of the host application's root layout, root error boundary and even root authentication boundary. This means that a hoisted route has full control over its rendering. To mark a route as hoisted, provide an hoist option to the route options.","By declaring a route as hoisted, other parts of the application will not be isolated anymore from this route's failures and the route will not be protected anymore by the application authenticated boundary.","To avoid breaking the entire application when an hoisted route encounters unhandled errors, it is highly recommended to declare a React Router's errorElement property for each hoisted route.","If the hoisted route requires an authentication, make sure to wrap the route with an authentication boundary or to handle the authentication within the route."]},{"l":"Register a public route","p":["When registering a route, a value can be provided indicating whether the route is public or protected. This is especially useful when dealing with code that fetches global data for protected routes(e.g. a session). Although a route definition accepts a $visibility value, we recommended using the runtime registerPublicRoute function to register a root public route instead.","To define a nested route as public, use the $visibility option:","When no $visibility indicator is provided, a route is considered protected."]},{"l":"Register a route with an id","p":["The registerRoute function accepts a parentId option, allowing a route to be nested under an existing parent route. When searching for the parent route matching the parentId option, the parentId will be matched against the $id option of every route.","A $id option should only be defined for routes that doesn't have a path like an error boundary or an authentication boundary."]},{"l":"Register nested routes","p":["React router nested routes enable applications to render nested layouts at various points within the router tree. This is quite helpful for modular applications as it enables composable and decoupled UI.","To fully harness the power of nested routes, the registerRoute function allows a route to be registered under any previously registered route, even if that route was registered by another module. The only requirement is that the parent route must have been registered with the registerRoute function.","When registering a new route with the registerRoute function, to render the route under a parent route, specify a parentPath option that matches the parent route's path option:","Or a parentId option that matches the parent route's $id option:","Learn more about using nested routes for modular tabs","The path option of a route rendered under an existing parent route must be a React Router absolute path (a path starting with a /). For example, if a parent route path is /layout, the path option of a route rendered under that parent route and responding to the /page-1 url, should be /layout/page-1.","Routes can also be nested by registering multiple routes in a single registration block:","A single registration block routes can also be define routes with relative paths(rather than starting with a /):"]},{"l":"Retrieve routes","p":["The registered routes are accessible from a FireflyRuntime instance, but keep in mind that the preferred way to retrieve the routes is with the useRoutes hook."]},{"l":"Register navigation items","p":["item: NavigationSection | NavigationLink.","options: An optional object literal of options:","menuId: An optional menu id to associate the item with.","sectionId: An optional section id of a parent navigation section to register this new item under.","A Squide navigation item can either be a NavigationLink or a NavigationSection. Both types can be intertwined to create a multi-level menu hierarchy. A NavigationSection item is used to setup a new level while a NavigationLink define a link."]},{"l":"NavigationLink","p":["Accept any properties of a React Router Link component with the addition of:","$id: An optional identifier for the link. Usually used as the React element key property.","$label: The link text.","$canRender: An optional function accepting an object and returning a boolean indicating whether or not the link should be rendered.","$priority: An order priority affecting the position of the item in the menu (higher first)","$additionalProps: Additional properties to be forwarded to the link renderer."]},{"l":"NavigationSection","p":["$id: An optional identifier for the section. Usually used to nest navigation items under a specific section and as the React element key property.","$label: The section text.","$canRender: An optional function accepting an object and returning a boolean indicating whether or not the section should be rendered.","$priority: An order priority affecting the position of the item in the menu (higher first)","$additionalProps: Additional properties to be forwarded to the section renderer.","children: The section content.","We recommend always providing an $id option for a navigation item, as it ensures the menus doesn't flicker when deferred registrations are updated. Be sure to use a unique identifier.","Setup the host application to render navigation items"]},{"l":"Register a navigation item with an id","p":["The registerNavigationItem function accepts a sectionId option, allowing a navigation item to be nested under an existing navigation section. When searching the parent navigation section matching the sectionId option, the sectionId will be match against the $id option of every navigation item.","Additionally, when combined with the useRenderedNavigationItems function, the $id option will be used as the React element key property."]},{"l":"Register nested navigation items","p":["Similarly to nested routes, a navigation item can be nested under an existing section be specifying a sectionId option that matches the section's $id option:","Navigation items can also be nested by registering multipe items in a single registration block:"]},{"l":"Register navigation items for a specific menu","p":["By default, every navigation item registered with the registerNavigationItem function is registered as part of the root navigation menu. To register a navigation item for a different navigation menu, specify a menuId option when registering the items."]},{"l":"Sort navigation items","p":["A $priority option can be added to a navigation item to affect it's position in the menu. The sorting algorithm is as follow:","By default a navigation item have a priority of 0.","If no navigation item have a priority, the items are positioned according to their registration order.","If an item have a priority 0, the item will be positioned before any other items with a lower priority (or without an explicit priority value).","If an item have a priority 0, the item will be positioned after any other items with a higher priority (or without an explicit priority value)."]},{"l":"Use dynamic segments for navigation items","p":["Learn more about rendering navigation items with dynamic segments"]},{"l":"Use a React element as navigation item label"},{"l":"Style a navigation item"},{"l":"Open a navigation link in a new tab"},{"l":"Conditionally render a navigation item","p":["It's the responsibility of the code rendering the menu to execute the navigation items $canRender function and conditionally render the items based on the return value."]},{"l":"Render additional props on a navigation item","p":["It's the responsibility of the code rendering the menu to handle the additional properties."]},{"l":"Retrieve navigation items","p":["The registered navigation items are accessible from a FireflyRuntime instance, but keep in mind that the preferred way to retrieve the navigation items is with the useNavigationItems hook.","By default, the getNavigationItems will return the navigation items for the root menu:","To retrieve the navigation items for a specific navigation menu, provide a menuId:"]},{"l":"Register request handlers","p":["The registered handlers must be valid MSW request handlers:","Learn more about setuping MSW"]},{"l":"Retrieve request handlers"},{"l":"Validate if MSW is enabled"},{"l":"Log a message"},{"l":"Use the event bus"},{"l":"Register an environment variable"},{"l":"Register multiple environment variables at once"},{"l":"Retrieve an environment variable"},{"l":"Retrieve all environment variables"},{"l":"Register a plugin","p":["The plugin factory function receives the Runtime instance as parameter.","Learn more about plugins"]},{"l":"Retrieve a plugin","p":["Learn more about plugins"]}],[{"l":"FireflyProvider","p":["React provider to share a FireflyRuntime instance between an host application and the modules."]},{"l":"Reference"},{"l":"Properties","p":["runtime: A FireflyRuntime instance."]},{"l":"Usage"},{"l":"Provide a runtime instance"},{"l":"Retrieve a runtime instance"}],[{"l":"useRuntime","p":["Retrieve a FireflyRuntime instance."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A FireflyRuntime instance."]},{"l":"Usage"}],[{"l":"useRuntimeMode","p":["Retrieve the runtime mode."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["Either development or production."]},{"l":"Usage"}],[{"l":"initializeFirefly","p":["Create a Runtime instance, register local modules and optionally start MSW. During the registration process, the modules' registration function will be invoked with a FireflyRuntime instance and an optional context object. To defer the registration of specific navigation items, a registration function can return an anonymous function."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","mode: An optional mode to optimize Squide for production. Values are development(default) and production.","localModules: An optional array of ModuleRegisterFunction.","context: An optional context object that will be pass to the registration function.","useMsw: An optional boolean value indicating whether or not to create the runtime with Mock Service Work(MSW) support.","startMsw: An optional function to register MSW request handlers and start MSW service. This function is required if MSW is enabled.","environmentVariables: An optional object of environment variables.","honeycombInstrumentationClient: An optional Honeycomb instrumentation client for tracing the Squide bootstrapping flow.","loggers: An optional array of logger instances.","plugins: An optional array of Plugin factory functions.","onError: An optional function that is called whenever a bootstrapping error occurs."]},{"l":"Returns","p":["A FireflyRuntime instance."]},{"l":"Usage"},{"l":"Change the runtime mode"},{"l":"Register a local module"},{"l":"Provide a registration context"},{"l":"Handle registration errors"},{"l":"Use MSW"},{"l":"Provide environment variables"},{"l":"Provide an Honeycomb instrumentation client"},{"l":"Register a logger","p":["The logger intance receives the Runtime instance as parameter."]},{"l":"Defer the registration of navigation items","p":["Sometimes, data must be fetched to determine which navigation items should be registered by a given module. To address this, Squide offers a two-phase registration mechanism:","The first phase allows modules to register their navigation items that are not dependent on initial data(in addition to their routes and MSW request handlers when fake endpoints are available).","The second phase enables modules to register navigation items that are dependent on initial data. Such a use case would be determining whether a navigation item should be registered based on a user profile. We refer to this second phase as deferred registrations.","To defer a registration to the second phase, a module registration function can return an anonymous function matching the DeferredRegistrationFunction type: (data, operation: register | update) = Promise | void.","Once the modules are registered, the deferred registration functions will be executed with the deferred data and register as the value for the operation argument. Afterward, whenever the deferred data changes, the deferred registration functions will be re-executed with the updated deferred data and update as the value for the operation argument.","Routes are always registered, but navigation items can be conditionally registered using a deferred registration function.","It's important to register conditional navigation items using the deferredRuntime argument rather than the root runtime argument.","useDeferredRegistrations"]},{"l":"Use the deferred registration operation argument"},{"l":"Register a plugin","p":["The plugin factory function receives the Runtime instance as parameter.","Learn more about plugins"]}],[{"l":"useDeferredRegistrations","p":["Register the modules deferred registration functions when the global data is initially fetched or update the deferred registration functions whenever the global data change.","This hook should always be used in combination with deferred registration functions and with either the usePublicDataQueries hook or the useProtectedDataQueries hook (can be both)."]},{"l":"Reference"},{"l":"Parameters","p":["data: An object literal of data that will be passed to the deferred registration functions.","options: An optional object literal of options:","onError: An optional function receiving an array of ModuleRegistrationError instances as argument."]},{"l":"Returns","p":["Nothing"]},{"l":"Usage"},{"l":"Register or update deferred registrations"},{"l":"Handle registration errors"}],[{"l":"mergeDeferredRegistrations","p":["Utility function that takes an array of deferred registration functions and returns a single function wrapping and merging all the provided deferred registration functions.","If the provided array contains undefined values, they will safely be ignored."]},{"l":"Reference"},{"l":"Parameters","p":["candidates: An array of deferred registration functions."]},{"l":"Returns","p":["A function or undefined:","If multiple deferred registration functions are provided, a single function wrapping and merging all the provided deferred registration functions is returned.","If a single deferred registration function is provided, the provided function is returned.","If no deferred registration functions are provided, undefined is returned."]},{"l":"Usage"}],[{"l":"AppRouter","p":["A component that sets up Squide's primitives with a React Router instance."]},{"l":"Reference"},{"l":"Properties","p":["waitForPublicData: An optional boolean value indicating whether or not Squide should delay the rendering of the requested page until the public data is ready. The default value is false.","waitForProtectedData: An optional boolean value indicating whether or not Squide should delay the rendering of the requested page until the protected data is ready. The default value is false.","children: A render function defining a RouterProvider component with rootRoute, registeredRoutes and routerProviderProps."]},{"l":"Usage"},{"l":"Define a router provider","p":["The rootRoute component provided as an argument to the AppRouter rendering function must always be rendered as a parent of the registeredRoutes."]},{"l":"Define a loading component","p":["A BootstrappingRoute component is introduced in the following example because the useIsBootstrapping hook must be rendered as a child of rootRoute."]},{"l":"Define a root error boundary","p":["A React Router errorElement retrieves the current error using the useRouteError hook.","The root error boundary should always wrap the registeredRoutes and, when application, the BootstrapingRoute component."]},{"l":"Delay rendering until the public data is ready","p":["A BootstrappingRoute component is introduced in the following example because the usePublicDataQueries hook must be rendered as a child of rootRoute."]},{"l":"Delay rendering until the protected data is ready","p":["A BootstrappingRoute component is introduced in the following example because the useProtectedDataQueries hook must be rendered as a child of rootRoute."]}],[{"l":"PublicRoutes","p":["A placeholder indicating where in the routing tree should the public routes be rendered. The PublicRoutes placeholder concept is similar to React Router's outlet, it's a pipeline to inject routes at a predetermined location.","A public route is a route with a public visibility that is not hoisted or nested with either a parentPath or parentId option."]},{"l":"Reference"},{"l":"Properties","p":["None"]},{"l":"Usage","p":["The route defining the PublicRoutes placeholder must be hoisted; otherwise, there will be an infinite loop as the PublicRoutes placeholder will render within itself."]}],[{"l":"ProtectedRoutes","p":["A placeholder indicating where in the routing tree should the protected routes be rendered. The ProtectedRoutes placeholder concept is similar to React Router's outlet, it's a pipeline to inject routes at a predetermined location.","A protected route is a route with a protected visibility that is not hoisted or nested with either a parentPath or parentId option."]},{"l":"Reference"},{"l":"Properties","p":["None"]},{"l":"Usage","p":["The route defining the ProtectedRoutes placeholder must be hoisted; otherwise, there will be an infinite loop as the ProtectedRoutes placeholder will render within itself."]}],[{"l":"useIsBootstrapping","p":["Indicate whether the application is currently being bootstrapped, such as registering modules, handling deferred registrations, preparing Mock Service Worker, fetching global data, etc."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A boolean value indicating whether or not the application is bootstrapping."]},{"l":"Usage","p":["A BootstrappingRoute component is introduced in the following example because this hook must be rendered as a child of rootRoute."]}],[{"l":"useRoutes","p":["Retrieve the registered routes from the FireflyRuntime instance."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["An array of Route."]},{"l":"Usage"}],[{"l":"useRouteMatch","p":["Execute React Router's matching algorithm against Squide's routes registry and a given location to determine if any route match the location."]},{"l":"Reference"},{"l":"Parameters","p":["locationArg: The location to match the route paths against.","options: An optional object literal of options:","throwWhenThereIsNoMatch: Whether or not to throw an Error if no route match locationArg."]},{"l":"Returns","p":["A Route object if there's a matching route, otherwise if throwWhenThereIsNoMatch is enabled and no route match the given location, an Error is thrown.","If throwWhenThereIsNoMatch is disabled and there's no route matching locationArg, undefined is returned."]},{"l":"Usage"},{"l":"Using useLocation"},{"l":"Using window.location"}],[{"l":"useIsRouteProtected","p":["Determine whether or not a route is considered as protected.","To take advantage of this hook, make sure to add a $visibility hint to your public pages."]},{"l":"Reference"},{"l":"Parameters","p":["route: A Route object."]},{"l":"Returns","p":["A boolean value indicating whether or not the matching route is protected."]},{"l":"Usage"}],[{"l":"resolveRouteSegments","p":["Replace a route segments (paths starting with :) with the provided values. For a value to be applied to a segment, the value key must match the segment minus the :."]},{"l":"Reference"},{"l":"Parameters","p":["to: A route with segments.","values: An object literal of segment values."]},{"l":"Returns","p":["The resolved route."]},{"l":"Usage"}],[{"l":"useRenderedNavigationItems","p":["Recursively parse a navigation items structure to transform the items into React Elements.","The useNavigationItems hook returns the navigation items tree structure as is, meaning the consumer has to recursively parse the structure to transform the items into actual React Elements.","As it's a non-trivial process, Squide provides this utility hook."]},{"l":"Reference"},{"l":"Parameters","p":["navigationItems: An array of NavigationLink | NavigationSection to render.","renderItem: A function to render a link from a navigation item","renderSection: A function to render a section from a collection of items."]},{"l":"NavigationLink","p":["Accept any properties of a React Router Link component with the addition of:","$id: An optional identifier for the link. Usually used as the React element key property.","$label: The link label. Could either by a string or a ReactNode.","$canRender: An optional function accepting an object and returning a boolean indicating whether or not the link should be rendered.","$additionalProps: An optional object literal of additional props to apply to the link component."]},{"l":"NavigationSection","p":["$id: An optional identifier the section. Usually used to nest navigation items undern a specific section and as the React element key property.","$label: The section label. Could either by a string or a ReactNode.","$canRender: An optional function accepting an object and returning a boolean indicating whether or not the section should be rendered.","$additionalProps: An optional object literal of additional props to apply to the section component.","children: The section items."]},{"l":"Returns","p":["An array of ReactElement."]},{"l":"Usage"},{"l":"Render nested items","p":["We recommend always providing an $id option for a navigation item, as it ensures the menus doesn't flicker when deferred registrations are updated. Be sure to use a unique key.","When no $id option is provided, a default key argument is computed based on the index and level properties. While this works in most cases, the default key cannot guarantee that the menu won't flicker during updates."]},{"l":"Render dynamic segments","p":["The to option of a navigation item can include dynamic segments (/user-profile/:userId), enabling the rendering of dynamic routes based on contextual values. To resolve a route dynamic segments, use the resolveRouteSegments function."]}],[{"l":"useNavigationItems","p":["Retrieve the registered navigation items from the FireflyRuntime instance."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","menuId: An optional id to retrieve the navigation menu for a specific menu."]},{"l":"Returns","p":["An array of NavigationLink | NavigationSection."]},{"l":"NavigationLink","p":["Accept any properties of a React Router Link component with the addition of:","$id: An optional identifier for the link. Usually used as the React element key property.","$label: The link label. Could either by a string or a ReactNode.","$canRender: An optional function accepting an object and returning a boolean indicating whether or not the link should be rendered.","$additionalProps: An optional object literal of additional props to apply to the link component."]},{"l":"NavigationSection","p":["$id: An optional identifier for the section. Usually used to nest navigation items under a specific section and as the React element key property.","$label: The section label. Could either by a string or a ReactNode.","$canRender: An optional function accepting an object and returning a boolean indicating whether or not the section should be rendered.","$additionalProps: An optional object literal of additional props to apply to the section component.","children: The section items."]},{"l":"Usage"},{"l":"Retrieve the items for the root menu"},{"l":"Retrieve the items for a specific menu"}],[{"l":"isNavigationLink","p":["Indicate whether or not a navigation item is a NavigationLink. This utility is particularly handy when rendering a menu with nested items."]},{"l":"Reference"},{"l":"Parameters","p":["item: A navigation item rendering props."]},{"l":"Returns","p":["A boolean value indicating whether or not the navigation item should be rendered as a link."]},{"l":"Usage"}],[{"l":"useEventBusDispatcher","p":["Use the FireflyRuntime instance event bus to dispatch an event."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A dispatch function: (eventName: string, payload?: {}) = void."]},{"l":"Usage"}],[{"l":"useEventBusListener","p":["Attach a listener to the FireflyRuntime instance event bus."]},{"l":"Reference"},{"l":"Parameters","p":["eventName: The name of the event to listen for.","callback: A function to be executed when a event matching the provided name is dispatched.","options: An optional object literal of options:","once: Whether or not the event listener should be automatically removed once an event as been handled."]},{"l":"Returns","p":["Nothing"]},{"l":"Usage"}],[{"l":"usePublicDataQueries","p":["Execute the specified Tanstack queries once the modules are ready and, when applicable, Mock Service Worker is also ready.","Use this hook to fetch public global data during the bootstrapping phase of your application. Avoid using it in product feature components."]},{"l":"Reference"},{"l":"Parameters","p":["queries: An array of QueriesOptions."]},{"l":"Returns","p":["An array of query response data. The order returned is the same as the input order."]},{"l":"Throws","p":["If an unmanaged error occur while performing any of the fetch requests, a GlobalDataQueriesError is thrown."]},{"l":"Usage"},{"l":"Define queries","p":["A BootstrappingRoute component is introduced in the following example because this hook must be rendered as a child of rootRoute."]},{"l":"waitForPublicData & useIsBootstrapping","p":["To ensure the AppRouter component wait for the public data to be ready before rendering the requested route, set the waitForPublicData property to true.","Combine this hook with the useIsBootstrapping hook to display a loader until the public data is fetched and the application is ready."]},{"l":"Handle fetch errors","p":["The usePublicDataQueries hook can throw GlobalDataQueriesError instances, which are typically unmanaged and should be handled by an error boundary. To assert in an error boundary that an error is an instance of GlobalDataQueriesError, use the isGlobalDataQueriesError function."]}],[{"l":"useProtectedDataQueries","p":["Execute the specified Tanstack queries when the modules are ready, the active route is protected and, when applicable, Mock Service Worker is ready.","Use this hook to fetch protected global data during the bootstrapping phase of your application. Avoid using it in product feature components."]},{"l":"Reference"},{"l":"Parameters","p":["queries: An array of QueriesOptions.","isUnauthorizedError: A function that returns a boolean value indicating whether or not the provided error is a 401 status code."]},{"l":"Returns","p":["An array of query response data. The order returned is the same as the input order."]},{"l":"Throws","p":["If an unmanaged error occur while performing any of the fetch requests, a GlobalDataQueriesError is thrown."]},{"l":"Usage"},{"l":"Define queries","p":["A BootstrappingRoute component is introduced in the following example because this hook must be rendered as a child of rootRoute."]},{"l":"waitForProtectedData & useIsBootstrapping","p":["To ensure the AppRouter component wait for the protected data to be ready before rendering the requested route, set the waitForProtectedData property to true.","Combine this hook with the useIsBootstrapping hook to display a loader until the protected data is fetched and the application is ready."]},{"l":"Handle fetch errors","p":["The useProtectedDataQueries hook can throw GlobalDataQueriesError instances, which are typically unmanaged and should be handled by an error boundary. To assert in an error boundary that an error is an instance of GlobalDataQueriesError, use the isGlobalDataQueriesError function."]},{"l":"Handle 401 response","p":["Unauthorized requests are a special case that shouldn't be handled by an error boundary, as this would cause an infinite loop with the application's authentication boundary.","To handle this, when the server returns a 401 status code, the useProtectedDataQueries hook instructs Squide to immediately render the page, triggering the authentication boundary, that will eventually redirect the user to a login page.","Since Squide manages this process behind the scenes, you only need to register an AuthenticationBoundary component and provide an isUnauthorizedError handler to the useProtectedDataQueries hook."]}],[{"l":"usePublicDataHandler","p":["Execute the specified handler once the modules are ready and, when applicable, Mock Service Worker is also ready."]},{"l":"Reference"},{"l":"Parameters","p":["handler: A void function."]},{"l":"Returns","p":["Nothing"]},{"l":"Usage"}],[{"l":"useProtectedDataHandler","p":["Execute the specified handler once the modules are ready, the active route is protected and, when applicable, Mock Service Worker is also ready."]},{"l":"Reference"},{"l":"Parameters","p":["handler: A void function."]},{"l":"Returns","p":["Nothing"]},{"l":"Usage"}],[{"l":"isGlobalDataQueriesError","p":["Indicates whether or not an error is an instance of GlobalDataQueriesError.","GlobalDataQueriesError errors are thrown by either the usePublicDataQueries hook or the useProtectedDataQueries hook and should usually be handled by an error boundary."]},{"l":"Reference"},{"l":"Parameters","p":["error: An Error instance."]},{"l":"Returns","p":["A boolean value indicating whether or not the error is an instance of GlobalDataQueriesError."]},{"l":"Usage"},{"l":"Handle within an error boundary"},{"l":"Handle with a try/catch"},{"l":"GlobalDataQueriesError","p":["message: The error message.","errors: An array of Error instances."]}],[{"l":"MswPlugin","p":["A plugin to faciliate the integration of Mock Service Worker(MSW) in a modular application."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","mswState: An optional object with the initial MSW state."]},{"l":"Usage"},{"l":"Register the plugin"},{"l":"Register the plugin with an initial state"}],[{"l":"i18nextPlugin","p":["A plugin to faciliate the integration of i18next in a modular application."]},{"l":"Reference"},{"l":"Parameters","p":["supportedLanguages: An array of languages supported by the application.","fallbackLanguage: The language to default to if none of the detected user's languages match any supported language.","queryStringKey: The querystring parameter lookup when detecting the user's language.","options: An optional object literal of options:","detection: An optional object literal accepting any LanguageDetector options."]},{"l":"Usage"},{"l":"Register the plugin"},{"l":"Retrieve the plugin instance","p":["Prefer using getI18nextPlugin when possible"]},{"l":"Register a i18next instance"},{"l":"Retrieve a i18next instance"},{"l":"Detect the user language","p":["Whenever a plugin instance is created, the user's language should always be detected immediatly using the detectUserLanguage function."]},{"l":"Retrieve the current language"},{"l":"Change the current language"},{"l":"Change the language detection order","p":["By default, the detection of the user's language is done first from the specified URL querystring parameter (?language in this example), then from the user's navigator language settings. The detection order can be changed by specifying a new value for the order detection option:"]},{"l":"Add an additional detection source"}],[{"l":"getI18nextPlugin","p":["Return an instance of i18nextPlugin from the list of plugins registered with a Runtime instance."]},{"l":"Reference"},{"l":"Parameters","p":["runtime: A runtime instance."]},{"l":"Returns","p":["An i18nextPlugin instance if the plugin has been registered, otherwise an Error is thrown."]},{"l":"Usage"}],[{"l":"useChangeLanguage","p":["Provide a function to change the current language of every i18next instance registered with the i18nextPlugin instance."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A function to change the current language of an i18nextPlugin instance: (newLanguage) = void."]},{"l":"Usage"}],[{"l":"useCurrentLanguage","p":["Retrieve the current language of the i18nextPlugin instance."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["The current language of the i18nextPlugin instance."]},{"l":"Usage","p":["Or with a typed language:"]}],[{"l":"useI18nextInstance","p":["Retrieve a registered i18next instance from the i18nextPlugin instance."]},{"l":"Reference"},{"l":"Parameters","p":["key: An instance key."]},{"l":"Returns","p":["An i18next instance."]},{"l":"Usage"},{"l":"Retrieve an instance"},{"l":"Use with the useTranslation hook"},{"l":"Use with the Trans component","p":["Or without the t function:"]}],[{"l":"I18nextNavigationItemLabel","p":["A React component to localize the label of Squide navigation items."]},{"l":"Reference"},{"l":"Properties","p":["i18next: An i18next instance.","namespace: An optional namespace for the localized resource. If no namespace is provided, the default namespace is navigationItems.","resourceKey: A localized resource key."]},{"l":"Usage","p":["Or with a difference resources namespace:"]}],[{"l":"EnvironmentVariablesPlugin","p":["A plugin to faciliate the usage of environment variables in a modular application."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","environmentVariables: An optional object of environment variables."]},{"l":"Usage"},{"l":"Register the plugin"},{"l":"Register the plugin with initial variables"}],[{"l":"EnvironmentVariables","p":["The EnvironmentVariables interface defines the shape and types of the environment-variable keys and values that modules register and access through the FireflyRuntime instance.","Consumer applications are expected to augment this interface to declare the variables they intend to register, providing a fully type-safe experience when working with environment variables."]},{"l":"Augment the interface","p":["First, create a types folder in the project:","Then create an env-vars.d.ts file:","Finally, update the project tsconfig.json to include the types folder:","Any project that uses these environment variables must also reference the project's env-vars.d.ts file:"]}],[{"l":"useEnvironmentVariable","p":["Retrieve a specific environment variable registered with the FireflyRuntime instance."]},{"l":"Reference"},{"l":"Parameters","p":["key: The environment variable key."]},{"l":"Returns","p":["The environment variable value if there's a match, otherwise an Error is thrown."]},{"l":"Usage"}],[{"l":"useEnvironmentVariables","p":["Retrieve all the environment variables registered with the FireflyRuntime instance."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["Returns all registered environment variables as an object literal. If no environment variables are registered, an empty object literal is returned."]},{"l":"Usage"}],[{"l":"useLogger","p":["Retrieve a logger instance from the FireflyRuntime instance. The returned logger will log messages to all registered logger instances."]},{"l":"Reference"},{"l":"Parameters","p":["None"]},{"l":"Returns","p":["A logger instance."]},{"l":"Usage"}],[{"l":"Plugin","p":["An abstract base class to define a plugin."]},{"l":"Protected members","p":["_runtime: Access the plugin Runtime instance."]},{"l":"Getters","p":["name: Return the name of the plugin."]},{"l":"Usage"},{"l":"Define a plugin"},{"l":"Register a plugin"},{"l":"Use a plugin runtime instance"},{"l":"Retrieve a plugin from a runtime instance"},{"l":"Retrieve a plugin with a custom function","p":["We recommend pairing a plugin definition with a custom function to retrieve the plugin from a runtime instance.","Retrieving a plugin with a custom function doesn't require the consumer to remember the plugin name, and has the upside of inferring the typings."]}],[{"l":"usePlugin","p":["Retrieve a plugin from the FireflyRuntime instance."]},{"l":"Reference"},{"l":"Parameters","p":["pluginName: The name of the plugin."]},{"l":"Returns","p":["A plugin instance if the plugin has been registered, otherwise an Error is thrown."]},{"l":"Usage"}],[{"l":"LocalStorageSessionManager","p":["A local storage session manager (strictly for development purpose)."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","key: An optional key identifying the session in localStorage."]},{"l":"Usage"},{"l":"Create a manager instance"},{"l":"Set a session"},{"l":"Get the current session"},{"l":"Clear the current session"}],[{"l":"ReadonlySessionLocalStorage","p":["Read a session object from the local storage (strictly for development purpose)."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","key: An optional key identifying the session in localStorage."]},{"l":"Usage"},{"l":"Create an accessor instance"},{"l":"Get the current session"}],[{"l":"initializeFireflyForStorybook","p":["Create a runtime instance tailored for Storybook and optionally register local modules."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","localModules: An optional array of ModuleRegisterFunction.","environmentVariables: An optional object of environment variables."]},{"l":"Returns","p":["A StorybookRuntime instance."]},{"l":"Usage"}],[{"l":"withFireflyDecorator","p":["Create a Decorator function that returns a FireflyDecorator component wrapping the story with all the required plumbing to render a component using Squide Firefly, including a RouterProvider."]},{"l":"Reference"},{"l":"Parameters","p":["runtime: A StorybookRuntime instance."]},{"l":"Returns","p":["A Decorator function."]},{"l":"Usage"}],[{"l":"FireflyDecorator","p":["Wrap a story with all the required plumbing to render a component using Squide Firefly, including a RouterProvider."]},{"l":"Reference"},{"l":"Properties","p":["runtime: A StorybookRuntime instance."]},{"l":"Usage"}],[{"l":"initializeFirefly","p":["This function is a wrapper around the original initializeFirefly function, adapted for use with Module Federation. This page documents only the differences between the original function and this adapted version."]},{"l":"Reference"},{"l":"Parameters","p":["options: An optional object literal of options:","remotes: An optional array of RemoteDefinition."]},{"l":"Returns","p":["A FireflyRuntime instance."]},{"l":"Usage"},{"l":"Register a remote module"},{"l":"Remote definition","p":["To ease the configuration of remote modules, make sure that you first import the RemoteDefinition type and assign it to your remote definitions array declaration."]},{"l":"name","p":["The name option of a remote definition must match the name option defined in the remote module ModuleFederationPlugin configuration.","If you are using either the Squide defineDevRemoteModuleConfig or defineBuildRemoteModuleConfig functions to add the ModuleFederationPlugin to the remote module webpack configuration object, then the remote module name is the second argument of the function.","In the following exemple, the remote module name is remote1."]}],[{"l":"defineDevHostConfig","p":["This is an experimental feature.","If the application does not include any remote modules, use the defineDevConfig function from @workleap/rsbuild-configs instead of the defineDevHostConfig function.","Creates an Rsbuild configuration object that is adapted for a Squide host application in development mode. This function is a wrapper built on top of @workleap/rsbuild-configs. Make sure to read the defineDevConfig documentation first."]},{"l":"Reference"},{"l":"Parameters","p":["port: The host application port.","remotes: An array of RemoteDefinition(view the Remote definition section).","options: An optional object literal of options:","Accepts most of Rsbuild definedDevConfig predefined options.","features: An optional object literal of feature switches to define additional shared dependencies.","i18next: Whether or not to add @squide/i18next as a shared dependency.","environmentVariables: false to remove @squide/env-vars from shared dependencies.","honeycomb: false to remove Honeycomb packages from shared dependencies.","msw: false to remove @squide/msw from shared dependencies.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["An Rsbuild configuration object tailored for a Squide host application in development mode."]},{"l":"Default shared dependencies","p":["The defineDevHostConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router","@squide/core","@squide/react-router","@squide/module-federation","@squide/msw","@squide/env-vars","@opentelemetry/api","For the full shared dependencies configuration, have a look at the defineConfig.ts file on Github."]},{"l":"Usage"},{"l":"Define an Rsbuild config"},{"l":"Activate optional features","p":["Features must be activated on the host application as well as every remote module."]},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous code sample, the react shared dependency will be augmented with the strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous code sample, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration"},{"l":"Remote definition"},{"l":"name","p":["The name option of a remote definition must match the name option defined in the remote module ModuleFederationPlugin configuration.","If you are relying on the Squide defineDevRemoteModuleConfig function to add the ModuleFederationPlugin to the remote module Rsbuild configuration object, then the remote module name is the first argument of the function.","In the following exemple, the remote module name is remote1."]},{"l":"url","p":["The url option of a remote definition must match the assetPrefix of the remote module Rsbuild configuration object.","In the following exemple, the remote module assetPrefix is http://localhost:8081.","The assetPrefix is built from the provided host and port values. Therefore, if the port value is 8081, then the generated assetPrefix would be http://localhost:8081:"]}],[{"l":"defineDevRemoteModuleConfig","p":["This is an experimental feature.","Creates an Rsbuild configuration object that is adapted for a Squide remote module application in development mode. This function is a wrapper built on top of @workleap/rsbuild-configs. Make sure to read the defineDevConfig documentation first."]},{"l":"Reference"},{"l":"Parameters","p":["applicationName: The remote module application name.","port: The remote module application port.","options: An optional object literal of options:","Accepts most of Rsbuild definedDevConfig predefined options.","features: An optional object literal of feature switches to define additional shared dependencies.","i18next: Whether or not to add @squide/i18next as a shared dependency.","environmentVariables: false to remove @squide/env-vars from shared dependencies.","honeycomb: false to remove Honeycomb packages from shared dependencies.","msw: false to remove @squide/msw from shared dependencies.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["An Rsbuild configuration object tailored for a Squide remote module application in development mode."]},{"l":"Conventions","p":["To fulfill Squide remote module requirements, the defineDevRemoteModuleConfig function will pre-configure the ModuleFederationPlugin with the following filename and exposes properties.","If the remote module port is 8081, the remote module bundle is available at http://localhost:8081/remoteEntry.js."]},{"l":"Default shared dependencies","p":["The defineDevRemoteModuleConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router","@squide/core","@squide/react-router","@squide/module-federation","@squide/msw","@squide/env-vars","@opentelemetry/api","For the full shared dependencies configuration, have a look at the defineConfig.ts file on Github."]},{"l":"Usage"},{"l":"Define a webpack config"},{"l":"Activate additional features","p":["Features must be activated on the host application as well as every remote module."]},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous code sample, the react shared dependency will be augmented with the newly provided strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous code sample, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration"},{"l":"Expose an additional module"}],[{"l":"defineBuildHostConfig","p":["This is an experimental feature.","If the application does not include any remote modules, use the defineBuildConfig function from @workleap/rsbuild-configs instead of the defineBuildHostConfig function.","Creates an Rsbuild configuration object that is adapted for a Squide host application in build mode. This function is a wrapper built on top of @workleap/rsbuild-configs. Make sure to read the defineBuildConfig documentation first."]},{"l":"Reference"},{"l":"Parameters","p":["remotes: An array of RemoteDefinition(view the Remote definition section).","options: An optional object literal of options:","Accepts most of Rsbuild definedBuildConfig predefined options.","features: An optional object literal of feature switches to define additional shared dependencies.","i18next: Whether or not to add @squide/i18next as a shared dependency.","environmentVariables: false to remove @squide/env-vars from shared dependencies.","honeycomb: false to remove Honeycomb packages from shared dependencies.","msw: false to remove @squide/msw from shared dependencies.","runtimePlugins: An optional array of module federation runtime plugins.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["An Rsbuild configuration object tailored for a Squide host application in build mode."]},{"l":"Default shared dependencies","p":["The defineBuildHostConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router","@squide/core","@squide/react-router","@squide/module-federation","@squide/msw","@squide/env-vars","@opentelemetry/api","For the full shared dependencies configuration, have a look at the defineConfig.ts file on GitHub."]},{"l":"Usage"},{"l":"Define an Rsbuild config"},{"l":"Activate additional features","p":["Features must be activated on the host application as well as every remote module."]},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous code sample, the react shared dependency will be augmented with the strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous code sample, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration"},{"l":"Remote definition"},{"l":"name","p":["The name option of a remote definition must match the name option defined in the remote module ModuleFederationPlugin configuration.","If you are relying on the Squide defineBuildRemoteModuleConfig function to add the ModuleFederationPlugin to the remote module Rsbuild configuration object, then the remote module name is the first argument of the function.","In the following exemple, the remote module name is remote1."]},{"l":"url","p":["The url option of a remote definition must match the assetPrefix of the remote module Rsbuild configuration object.","In the following exemple, the remote module assetPrefix is http://localhost:8081."]}],[{"l":"defineBuildRemoteModuleConfig","p":["This is an experimental feature.","Creates an Rsbuild configuration object that is adapted for a Squide remote module application in build mode. This function is a wrapper built on top of @workleap/rsbuild-configs. Make sure to read the defineBuildConfig documentation first."]},{"l":"Reference"},{"l":"Parameters","p":["applicationName: The remote module application name.","options: An optional object literal of options:","Accepts most of Rsbuild definedDevConfig predefined options.","features: An optional object literal of feature switches to define additional shared dependencies.","i18next: Whether or not to add @squide/i18next as a shared dependency.","environmentVariables: false to remove @squide/env-vars from shared dependencies.","honeycomb: false to remove Honeycomb packages from shared dependencies.","msw: false to remove @squide/msw from shared dependencies.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["An Rsbuild configuration object tailored for a Squide remote module application in build mode."]},{"l":"Conventions","p":["To fulfill Squide remote module requirements, the defineBuildRemoteModuleConfig function will pre-configure the ModuleFederationPlugin with the following filename and exposes properties.","If the remote module assetsPrefix is http://localhost/8081, the remote module bundle is available at http://localhost:8081/remoteEntry.js."]},{"l":"Default shared dependencies","p":["The defineBuildRemoteModuleConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router","@squide/core","@squide/react-router","@squide/module-federation","@squide/msw","@squide/env-vars","@opentelemetry/api","For the full shared dependencies configuration, have a look at the defineConfig.ts file on Github."]},{"l":"Usage"},{"l":"Define an Rsbuild config"},{"l":"Activate additional features","p":["Features must be activated on the host application as well as every remote module."]},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous code sample, the react shared dependency will be augmented with the newly provided strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous code sample, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration"},{"l":"Expose an additional module"}],[{"l":"defineDevHostConfig","p":["If the application does not include any remote modules, use the defineDevConfig function from @workleap/webpack-configs instead of the defineDevHostConfig function.","Creates a webpack configuration object that is adapted for a Squide host application in development mode. This function is a wrapper built on top of @workleap/webpack-configs. Make sure to read the defineDevConfig documentation first."]},{"l":"Reference"},{"l":"Parameters","p":["swcConfig: An SWC configuration object.","port: The host application port.","remotes: An array of RemoteDefinition(view the Remote definition section).","options: An optional object literal of options:","Accepts most of webpack definedDevConfig predefined options.","htmlWebpackPluginOptions: An optional object literal accepting any options of the HtmlWebpackPlugin.","features: An optional object literal of feature switches to define additional shared dependencies.","i18next: Whether or not to add @squide/i18next as a shared dependency.","environmentVariables: false to remove @squide/env-vars from shared dependencies.","honeycomb: false to remove Honeycomb packages from shared dependencies.","msw: false to remove @squide/msw from shared dependencies.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["A webpack configuration object tailored for a Squide host application in development mode."]},{"l":"Default shared dependencies","p":["The defineDevHostConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router","@squide/core","@squide/react-router","@squide/module-federation","@squide/msw","@squide/env-vars","@opentelemetry/api","For the full shared dependencies configuration, have a look at the defineConfig.ts file on Github."]},{"l":"Usage"},{"l":"Define a webpack config"},{"l":"Activate optional features","p":["Features must be activated on the host application as well as every remote module."]},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous code sample, the react shared dependency will be augmented with the strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous code sample, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration","p":["While you could customize the ModuleFederationPlugin configuration by providing your own object literal through the moduleFederationPluginOptions option, we recommend using the defineHostModuleFederationPluginOptions(options) function as it will take care of merging the custom options with the default plugin options.","applicationName: The host application name.","moduleFederationPluginOptions: An object literal of ModuleFederationPlugin options."]},{"l":"Remote definition"},{"l":"name","p":["The name option of a remote definition must match the name option defined in the remote module ModuleFederationPlugin configuration.","If you are relying on the Squide defineDevRemoteModuleConfig function to add the ModuleFederationPlugin to the remote module webpack configuration object, then the remote module name is the second argument of the function.","In the following exemple, the remote module name is remote1."]},{"l":"url","p":["The url option of a remote definition must match the publicPath of the remote module webpack configuration object.","In the following exemple, the remote module publicPath is http://localhost:8081.","The publicPath is built from the provided host and port values. Therefore, if the port value is 8081, then the generated publicPath would be http://localhost:8081:"]}],[{"l":"defineDevRemoteModuleConfig","p":["Creates a webpack configuration object that is adapted for a Squide remote module application in development mode. This function is a wrapper built on top of @workleap/webpack-configs. Make sure to read the defineDevConfig documentation first."]},{"l":"Reference"},{"l":"Parameters","p":["swcConfig: An SWC configuration object.","applicationName: The remote module application name.","port: The remote module application port.","options: An optional object literal of options:","Accepts most of webpack definedDevConfig predefined options.","features: An optional object literal of feature switches to define additional shared dependencies.","i18next: Whether or not to add @squide/i18next as a shared dependency.","environmentVariables: false to remove @squide/env-vars from shared dependencies.","honeycomb: false to remove Honeycomb packages from shared dependencies.","msw: false to remove @squide/msw from shared dependencies.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["A webpack configuration object tailored for a Squide remote module application in development mode."]},{"l":"Conventions","p":["To fulfill Squide remote module requirements, the defineDevRemoteModuleConfig function will pre-configure the ModuleFederationPlugin with the following filename and exposes properties.","If the remote module port is 8081, the remote module bundle is available at http://localhost:8081/remoteEntry.js."]},{"l":"Default shared dependencies","p":["The defineDevRemoteModuleConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router","@squide/core","@squide/react-router","@squide/module-federation","@squide/msw","@squide/env-vars","@opentelemetry/api","For the full shared dependencies configuration, have a look at the defineConfig.ts file on Github."]},{"l":"Usage"},{"l":"Define a webpack config"},{"l":"Activate additional features","p":["Features must be activated on the host application as well as every remote module."]},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous code sample, the react shared dependency will be augmented with the newly provided strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous code sample, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration","p":["While you could customize the ModuleFederationPlugin configuration by providing your own object literal through the moduleFederationPluginOptions option, we recommend using the defineRemoteModuleFederationPluginOptions(applicationName, options) function as it will take care of merging the custom options with the default plugin options.","applicationName: The host application name.","moduleFederationPluginOptions: An object literal of ModuleFederationPlugin options."]},{"l":"Expose an additional module"}],[{"l":"defineBuildHostConfig","p":["If the application does not include any remote modules, use the defineBuildConfig function from @workleap/webpack-configs instead of the defineBuildHostConfig function.","Creates a webpack configuration object that is adapted for a Squide host application in build mode. This function is a wrapper built on top of @workleap/webpack-configs. Make sure to read the defineBuildConfig documentation first."]},{"l":"Reference"},{"l":"Parameters","p":["swcConfig: An SWC configuration object.","remotes: An array of RemoteDefinition(view the Remote definition section).","options: An optional object literal of options:","Accepts most of webpack definedBuildConfig predefined options.","htmlWebpackPluginOptions: An optional object literal accepting any options of the HtmlWebpackPlugin.","features: An optional object literal of feature switches to define additional shared dependencies.","i18next: Whether or not to add @squide/i18next as a shared dependency.","environmentVariables: false to remove @squide/env-vars from shared dependencies.","honeycomb: false to remove Honeycomb packages from shared dependencies.","msw: false to remove @squide/msw from shared dependencies.","runtimePlugins: An optional array of module federation runtime plugins.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["A webpack configuration object tailored for a Squide host application in build mode."]},{"l":"Default shared dependencies","p":["The defineBuildHostConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router","@squide/core","@squide/react-router","@squide/module-federation","@squide/msw","@squide/env-vars","@opentelemetry/api","For the full shared dependencies configuration, have a look at the defineConfig.ts file on GitHub."]},{"l":"Usage"},{"l":"Define a webpack config"},{"l":"Activate additional features","p":["Features must be activated on the host application as well as every remote module."]},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous code sample, the react shared dependency will be augmented with the strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous code sample, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration","p":["While you could customize the ModuleFederationPlugin configuration by providing your own object literal through the moduleFederationPluginOptions option, we recommend using the defineHostModuleFederationPluginOptions(options) function as it will take care of merging the custom options with the default plugin options.","applicationName: The host application name.","moduleFederationPluginOptions: An object literal of ModuleFederationPlugin options."]},{"l":"Remote definition"},{"l":"name","p":["The name option of a remote definition must match the name option defined in the remote module ModuleFederationPlugin configuration.","If you are relying on the Squide defineBuildRemoteModuleConfig function to add the ModuleFederationPlugin to the remote module webpack configuration object, then the remote module name is the second argument of the function.","In the following exemple, the remote module name is remote1."]},{"l":"url","p":["The url option of a remote definition must match the publicPath of the remote module webpack configuration object.","In the following exemple, the remote module publicPath is http://localhost:8081."]}],[{"l":"defineBuildRemoteModuleConfig","p":["Creates a webpack configuration object that is adapted for a Squide remote module application in build mode. This function is a wrapper built on top of @workleap/webpack-configs. Make sure to read the defineBuildConfig documentation first."]},{"l":"Reference"},{"l":"Parameters","p":["swcConfig: An SWC configuration object.","applicationName: The remote module application name.","options: An optional object literal of options:","Accepts most of webpack definedDevConfig predefined options.","features: An optional object literal of feature switches to define additional shared dependencies.","i18next: Whether or not to add @squide/i18next as a shared dependency.","environmentVariables: false to remove @squide/env-vars from shared dependencies.","honeycomb: false to remove Honeycomb packages from shared dependencies.","msw: false to remove @squide/msw from shared dependencies.","sharedDependencies: An optional object literal of additional (or updated) module federation shared dependencies.","moduleFederationPluginOptions: An optional object literal of ModuleFederationPlugin options."]},{"l":"Returns","p":["A webpack configuration object tailored for a Squide remote module application in build mode."]},{"l":"Conventions","p":["To fulfill Squide remote module requirements, the defineBuildRemoteModuleConfig function will pre-configure the ModuleFederationPlugin with the following filename and exposes properties.","If the remote module publicPath is http://localhost/8081, the remote module bundle is available at http://localhost:8081/remoteEntry.js."]},{"l":"Default shared dependencies","p":["The defineBuildRemoteModuleConfig function will add the following shared dependencies as singleton by default:","react","react-dom","react-router","@squide/core","@squide/react-router","@squide/module-federation","@squide/msw","@squide/env-vars","@opentelemetry/api","For the full shared dependencies configuration, have a look at the defineConfig.ts file on Github."]},{"l":"Usage"},{"l":"Define a webpack config"},{"l":"Activate additional features","p":["Features must be activated on the host application as well as every remote module."]},{"l":"Specify additional shared dependencies","p":["Additional shared dependencies must be configured on the host application as well as every remote module."]},{"l":"Extend a default shared dependency","p":["In the previous code sample, the react shared dependency will be augmented with the newly provided strictVersion option. The resulting shared dependency will be:"]},{"l":"Override a default shared dependency","p":["In the previous code sample, the react shared dependency singleton option will be overrided by the newly provided value. The resulting shared dependency will be:"]},{"l":"Customize module federation configuration","p":["While you could customize the ModuleFederationPlugin configuration by providing your own object literal through the moduleFederationPluginOptions option, we recommend using the defineRemoteModuleFederationPluginOptions(applicationName, options) function as it will take care of merging the custom options with the default plugin options.","applicationName: The host application name.","moduleFederationPluginOptions: An object literal of ModuleFederationPlugin options."]},{"l":"Expose an additional module"}],[{"l":"Updating","p":["Migrate to firefly v9.0","Migrate to firefly v9.3","Migrate to firefly v10.0","Migrate to firefly v11.0","Migrate to firefly v12.0","Migrate to firefly v13.0","Migrate to firefly v14.0","Migrate to firefly v15.0","Migrate to firefly v16.0","Migrate from v8 to v15.0","Migrate to Rsbuild","Migrate to Just-In-Time (JIT) packages"]}],[{"l":"Migrate to firefly v9.0","p":["If you are migrating from v8.*, follow the Migrate from v8.* to v15.0 guide.","Although this migration guide is labeled for version 9.0.0, it is actually intended for migrating from version 8.* to version 9.2.1. Therefore, please ensure you upgrade to @squide/firefly version 9.2.1 instead of 9.0.0.","We apologize for the confusion.","This major version of @squide/firefly introduces TanStack Query as the official library for fetching the global data of a Squide's application and features a complete rewrite of the AppRouter component, which now uses a state machine to manage the application's bootstrapping flow.","Prior to v9.0, Squide applications couldn't use TanStack Query to fetch global data, making it challenging for Workleap's applications to keep their global data in sync with the server state. With v9.0, applications can now leverage custom wrappers of the TanStack Query's useQueries hook to fetch and keep their global data up-to-date with the server state. Additionally, the new deferred registrations update feature allows applications to even keep their conditional navigation items in sync with the server state.","Finally, with v9.0, Squide's philosophy has evolved. We used to describe Squide as a shell for federated applications. Now, we refer to Squide as a shell for modular applications. After playing with Squide's local module feature for a while, we discovered that Squide offers significant value even for non-federated applications, which triggered this shift in philosophy."]},{"l":"Breaking changes"},{"l":"Removed","p":["The useAreModulesRegistered hook has been removed, use the useIsBootstrapping hook instead.","The useAreModulesReady hook has been removed, use the useIsBootstrapping hook instead.","The useIsMswStarted hook has been removed, use the useIsBootstrapping hook instead.","The completeModuleRegistrations function as been removed use the useDeferredRegistrations hook instead.","The completeLocalModulesRegistrations function has been removed use the useDeferredRegistrations hook instead.","The completeRemoteModuleRegistrations function has been removed use the useDeferredRegistrations hook instead.","The useSession hook has been removed, define your own React context instead.","The useIsAuthenticated hook has been removed, define your own React context instead.","The sessionAccessor option has been removed from the FireflyRuntime options, define your own React context instead.","The ManagedRoutes placeholder has been removed, use PublicRoutes and ProtectedRoutes instead."]},{"l":"Renamed","p":["The setMswAsStarted function has been renamed to setMswIsReady.","A route definition $name option has been renamed to $id.","The registerRoute parentName option has been renamed to parentId."]},{"l":"Others","p":["The @squide/firefly package now takes a peerDependency on @tanstack/react-query.","The @squide/firefly package doesn't takes a peerDependency on react-error-boundary anymore."]},{"l":"Removed support for deferred routes","p":["Deferred registration functions no longer support route registration; they are now exclusively used for registering navigation items. Since deferred registration functions can now be re-executed whenever the global data changes, registering routes in deferred registration functions no longer makes sense as updating the routes registry after the application has bootstrapped could lead to issues.","This change is a significant improvement for Squide's internals, allowing us to eliminate quirks like:","Treating unknown routes as protected: When a user initially requested a deferred route, Squide couldn't determine if the route was public or protected because it wasn't registered yet. As a result, for that initial request, the route was considered protected, even if the deferred registration later registered it as public.","Mandatory wildcard * route registration: Previously, Squide's bootstrapping would fail if the application didn't include a wildcard route.","Before:","Now:"]},{"l":"Conditional routes","p":["To handle direct access to a conditional route, each conditional route's endpoint should return a 403 status code if the user is not authorized to view the route. Those 403 errors should then be handled by the nearest error boundary."]},{"l":"Plugin's constructors now requires a runtime instance","p":["Prior to this release, plugin instances received the current runtime instance through a _setRuntime function. This approach caused issues because some plugins required a reference to the runtime at instantiation. To address this, plugins now receive the runtime instance directly as a constructor argument.","Before:","Now:"]},{"l":"Plugins now registers with a factory function","p":["Prior to this release, the FireflyRuntime accepted plugin instances as options. Now, FireflyRuntime accepts factory functions instead of plugin instances. This change allows plugins to receive the runtime instance as a constructor argument.","Before:","Now:"]},{"l":"Rewrite of the AppRouter component","p":["This release features a full rewrite of the AppRouter component. The AppRouter component used to handle many concerns like global data fetching, deferred registrations, error handling and a loading state. Those concerns have been delegated to the consumer code, supported by the new useIsBootstrapping, usePublicDataQueries, useProtectedDataQueries and useDeferredRegistrations hooks.","Before:","Now:"]},{"l":"New hooks and functions","p":["A new useIsBoostrapping hook is now available.","A new useDeferredRegistrations hook is now available.","A new usePublicDataQueries hook is now available.","A new useProtectedDataQueries hook is now available.","A new isGlobalDataQueriesError function is now available.","A new registerPublicRoute function is now available."]},{"l":"Improvements","p":["Deferred registration functions now always receive a data argument.","Deferred registration functions now receives a new operations argument.","Navigation items now include a $canRender option, enabling modules to control whether a navigation item should be rendered."]},{"l":"New $id option for navigation items","p":["Navigation items now supports a new $id option. Previously, most navigation item React elements used a key property generated by concatenating the item's level and index, which goes against React's best practices:","It wasn't that much of a big deal since navigation items never changed once the application was bootstrapped. Now, with the deferred registration functions re-executing when the global data changes, the registered navigation items can be updated post-bootstrapping. The new $id option allows the navigation item to be configured with a unique key at registration, preventing UI shifts.","The configured $id option is then passed as a key argument to the useRenderedNavigationItems rendering functions:","If no $id is configured for a navigation item, the key argument will be a concatenation of the level and index argument."]},{"l":"Migrate an host application","p":["A migration example from v8 to v9 is available for the wl-squide-monorepo-template.","Add a dependency to @tanstack/react-query.","Add an $id option to the navigation item registrations. View example","Add or update the AuthenticationBoundary component to use the new useIsAuthenticated hook. Global data fetch request shouldn't be throwing 401 error anymore when the user is not authenticated. View example","Convert all deferred routes into static routes. View example","Create a TanStackSessionManager class and the SessionManagerContext. Replace the session's deprecated hooks by creating the customs useSession and useIsAuthenticated hooks. View example","errorElement is removed and somewhat replaced by a root error boundary","fallbackElement becomes useIsBootstrapping","onCompleteRegistrations becomes useDeferredRegistrations","onLoadProtectedData+ isProtectedDataLoaded becomes useProtectedDataQueries","onLoadPublicData+ isPublicDataLoaded becomes usePublicDataQueries","Remove the sessionAccessor option from the FireflyRuntime instance. Update the BootstrappingRoute component to create a TanStackSessionManager instance and share it down the component tree using a SessionManagedContext provider. View example","Replace the ManagedRoutes placeholder with the new PublicRoutes and ProtectedRoutes placeholders. View example","The v9.0 release introduces several breaking changes affecting the host application code. Follow these steps to migrate an existing host application:","Transition to the new AppRouter component. View example","Update the AuthenticatedLayout component to use the new key argument. View example","Update the AuthenticatedLayout component to use the session manager instance to clear the session. Retrieve the session manager instance from the context defined in the BootstrappingRoute component using the useSessionManager hook. View example"]},{"l":"waitForMsw, waitForPublicData, waitForProtectedData","p":["The AppRouter component accepts the waitForMsw, waitForPublicData, and waitForProtectedData properties. These properties are forwarded directly to the Squide bootstrapping flow state machine, where they are used to determine its initial state.","If the application register MSW request handlers with the runtime.registerRequestHandlers function, add the waitForMsw property to the AppRouter component:","If the application uses the usePublicDataQueries, add the waitForPublicData property to the AppRouter component:","If the application uses the useProtectedDataQueries, add the waitForProtectedData property to the AppRouter component:","Otherwise, don't define any of those three properties on the AppRouter component."]},{"l":"Root error boundary","p":["When transitioning to the new AppRouter component, make sure to nest the RootErrorBoundary component within the AppRouter component's render function.","Before:","Now:"]},{"l":"Migrate a module","p":["A migration example from v8 to v9 is available for the wl-squide-monorepo-template.","The changes in v9.0 have minimal impact on module code. To migrate an existing module, follow these steps:","Convert all deferred routes into static routes. View example","Add a $id option to the navigation item registrations. View example","Ensure that modules registering deferred routes are updated to convert those routes into static routes and are deployed before the host application. Failure to do so may lead to runtime errors in the production environment."]},{"l":"Isolated development","p":["If your module is set up for isolated development, ensure that you also apply the host application migration steps to your isolated setup."]}],[{"l":"Migrate to firefly v9.3","p":["If you are migrating from v8.*, follow the Migrate from v8.* to v15.0 guide.","This minor version deprecate the registerLocalModules, registerRemoteModules and setMswAsReady in favor of a bootstrap function."]},{"l":"Deprecation","p":["The registerLocalModules function has been deprecated, use the bootstrap function instead.","The registerRemoteModules function has been deprecated, use the bootstrap function instead.","The setMswAsReady function has been deprecated, use the bootstrap function instead."]},{"l":"Migrate an host application","p":["The bootstrap function is a new primitive that simplifies the bootstrapping of a Squide application. It replaces the registerLocalModules, registerRemoteModules and setMswAsReady functions."]},{"l":"Modules registration","p":["To update an application's module registration code, replace the registerLocalModules and registerRemoteModules functions with a call to the bootstrap function:","Before:","Now:"]},{"l":"Mock Service Worker","p":["The MSW bootstrapping logic has been moved from user code to the bootstrap function. To update an application, replace the user code with the startMsw option of the bootstrap function.","Before:","Now:"]}],[{"l":"Migrate to firefly v10.0","p":["If you are migrating from v8.*, follow the Migrate from v8.* to v15.0 guide.","This major version introduces support for React Router v7. The peer dependencies for @squide/firefly and @squide/react-router have been updated from react-router-dom@6* to react-router@7* and the React Router shared dependency name has been renamed from react-router-dom to react-router for @squide/firefly-webpack-configs and @squide/firefly-rsbuild-configs."]},{"l":"Breaking changes","p":["All breaking changes in firefly v10 are due to the migration to React Router v7. For official guidance on upgrading from React Router v6 to v7, refer to the official migration guide.","If you are app is already on React Router v7, you don't have to deal with any breaking changes for firefly v10."]},{"l":"React Router future flags","p":["Before migrating to Squide firefly v10 or React Router v7, it is highly recommended to read React Router migration guide and activate the \"future flags\" one by one to minimize breaking changes.","Before:","Now:","If your application is already on React Router v7, you can ignore this advice."]},{"l":"Replace react-router-dom with react-router","p":["In React Router v7, react-router-dom is no longer required, as the package structure has been simplified. All necessary imports are now available from either react-router or react-router/dom."]},{"l":"Update dependencies","p":["Open a terminal at the root of the project workspace and use the following commands to remove react-router-dom and install react-router@latest:"]},{"l":"Update Imports","p":["In your code, update all imports from react-router-dom to react-router, except for RouterProvider, which must be imported from react-router/dom.","Before:","Now:","According to React Router migration guide, you can use the following command to update the imports from react-router-dom to react-router:"]}],[{"l":"Migrate to firefly v11.0","p":["If you are migrating from v8.*, follow the Migrate from v8.* to v15.0 guide.","This major version transform the bootstrap function from an async function a sync function. It also introduces a new FireflyProvider alias for RuntimeContext.Provider."]},{"l":"Breaking changes"},{"l":"bootstrap","p":["The bootstrap function is not async anymore and stop returning the bootstrapping errors:","Before:","Now:","To handle bootstrapping errors, an onError handler can be provided."]},{"l":"Optional changes"},{"l":"Replace RuntimeContext.Provider by FireflyProvider","p":["A new FireflyProvider has been introduced to replace RuntimeContext.Provider. This change is optionnal as both are still supported, but strongly encouraged.","Before:","Now:"]}],[{"l":"Migrate to firefly v12.0","p":["If you are migrating from v8.*, follow the Migrate from v8.* to v15.0 guide.","This major version introduces a new initializeFirefly function, replacing the bootstrap function. This new initializeFirefly function is similar the previous bootstrap function with the addition that it takes care of creating and returning a Runtime instance.","This major version introduces a new initializeFirefly function that replaces the legacy bootstrap function. In addition to providing similar functionality, initializeFirefly creates and returns a Runtime instance."]},{"l":"Breaking changes"},{"l":"Removed","p":["The bootstrap function has been removed, use the initializeFirefly function instead.","The waitForMsw property has been removed from the AppRouter component."]},{"l":"Replaced bootstrap by initializeFirefly","p":["The bootstrap function has been replaced by the initializeFirefly function. This new function behaves similarly to the former `bootstrap function, accepting all its previous arguments, but additionally creates and returns a Runtime instance.","Before:","Now:"]},{"l":"Remove the waitForMsw property of AppRouter","p":["Because the initializeFirefly function accepts the useMsw option, the Squide Firefly state machine automatically detects when the application is using Mock Service Worker, eliminating the need to specify the value again.","Before:","Now:"]}],[{"l":"Migrate to firefly v13.0","p":["If you are migrating from v8.*, follow the Migrate from v8.* to v15.0 guide.","This major version deprecates the @squide/firefly-honeycomb package in favor of @workleap/honeycomb.","Host applications can now automatically get Honeycomb performance traces for Squide's' applications by registering @workleap/honeycomb v5 or higher instrumentation.","When a host application registers @workleap/honeycomb instrumentation, Squide will detect it automatically and dynamically register everything needed to traces to performance of it's bootstrapping process, no additional setup required."]},{"l":"Breaking changes"},{"l":"@squide/firefly-honeycomb deprecation","p":["Host application should now register Honeycomb instrumentation using @workleap/honeycomb instead of @squide/firefly-honeycomb.","To ensure full functionality, make sure to register the Honeycomb instrumentation before initializing Squide.","Before:","After:"]}],[{"l":"Migrate to firefly v14.0","p":["If you are migrating from v8.*, follow the Migrate from v8.* to v15.0 guide.","This major version introduces a new first argument to deferred registration functions."]},{"l":"Breaking changes"},{"l":"New runtime instance argument for deferred registration function","p":["A new first argument is provided to deferred registration functions: a scoped runtime instance.","This new scoped runtime instance argument should be used whenever runtime access is required, instead of the root runtime provided to module registration function.","Reminder: A deferred registration function is a function returned by a module registration function and is executed later, once global data has been fetched. A common use case for deferred registrations is conditionally rendering navigation items.","Placing the runtime argument first is intentional: it emphasizes that consumers should rely on this specific runtime within the deferred registration function scope, rather than the root runtime instance passed to the module registration function.","Before:","The runtime argument of the registration function is used to register the navigation item.","After:","The deferredRuntime argument of the deferred registration function is used to register the navigation item."]}],[{"l":"Migrate to firefly v15.0","p":["If you are migrating from v8.*, follow the Migrate from v8.* to v15.0 guide.","This major version changes how Squide integrates with Honeycomb. In previous versions, the Honeycomb integration depended on global variables registered by the @workleap/honeycomb package. Starting with this version, Squide integrates with Honeycomb only when it is initialized with a HoneycombInstrumentationClient instance.","The following example demonstrates how to integrate Squide with Honeycomb using the @workleap/telemetry package. However, you can also integrate Honeycomb with the standalone @workleap/honeycomb package.","Before:","Now:"]}],[{"l":"Migrate to firefly v16.0","p":["This major version removes Module Federation from @squide/firefly. Module Federation is now optional and can be enabled by installing the @squide/firefly-module-federation package. To register remote modules, import the initializeFirefly function from @squide/firefly-module-federation instead of @squide/firefly.","First, install the @squide/firefly-module-federation package:","Then, follow this example to register remote modules using the new @squide/firefly-module-federation package.","Before:","After:"]}],[{"l":"Migrate from v8.* to v15.0","p":["This migration guide is an aggregation of all the changes that happened between Squide Firefly v9.0 and v15.0:"]},{"l":"Changes summary"},{"l":"v9.0","p":["Migrate to firefly v9.0","This major version of @squide/firefly introduces TanStack Query as the official library for fetching the global data of a Squide's application and features a complete rewrite of the AppRouter component, which now uses a state machine to manage the application's bootstrapping flow.","Prior to v9.0, Squide applications couldn't use TanStack Query to fetch global data, making it challenging for Workleap's applications to keep their global data in sync with the server state. With v9.0, applications can now leverage custom wrappers of the TanStack Query's useQueries hook to fetch and keep their global data up-to-date with the server state. Additionally, the new deferred registrations update feature allows applications to even keep their conditional navigation items in sync with the server state.","Finally, with v9.0, Squide's philosophy has evolved. We used to describe Squide as a shell for federated applications. Now, we refer to Squide as a shell for modular applications. After playing with Squide's local module feature for a while, we discovered that Squide offers significant value even for non-federated applications, which triggered this shift in philosophy."]},{"l":"v9.3","p":["Migrate to firefly v9.3","This minor version deprecate the registerLocalModules, registerRemoteModules in favor of a bootstrap function."]},{"l":"v10.0","p":["Migrate to firefly v10.0","This major version introduces support for React Router v7. The peer dependencies for @squide/firefly and @squide/react-router have been updated from react-router-dom@6* to react-router@7* and the React Router shared dependency name has been renamed from react-router-dom to react-router for @squide/firefly-webpack-configs and @squide/firefly-rsbuild-configs."]},{"l":"v11.0","p":["Migrate to firefly v11.0","This major version transform the bootstrap function from an async function a sync function. It also introduces a new FireflyProvider alias for RuntimeContext.Provider."]},{"l":"v12.0","p":["Migrate to firefly v12.0","This major version introduces a new initializeFirefly function, replacing the bootstrap function. This new initializeFirefly function is similar to the previous bootstrap function with the addition that it takes care of creating and returning a Runtime instance and initializing other internal features of Squide."]},{"l":"v13.0","p":["Migrate to firefly v13.0","This major version deprecates the @squide/firefly-honeycomb package in favor of @workleap/honeycomb."]},{"l":"v14.0","p":["Migrate to firefly v14.0","This major version introduces a new first argument to deferred registration functions."]},{"l":"v15.0","p":["Migrate to firefly v15.0","This major version changes how Squide integrates with Honeycomb. In previous versions, the Honeycomb integration depended on global variables registered by the @workleap/honeycomb package. Starting with this version, Squide integrates with Honeycomb only when it is initialized with a HoneycombInstrumentationClient instance."]},{"l":"Breaking changes"},{"l":"Removed","p":["The useAreModulesRegistered hook has been removed, use the useIsBootstrapping hook instead.","The useAreModulesReady hook has been removed, use the useIsBootstrapping hook instead.","The useIsMswStarted hook has been removed, use the useIsBootstrapping hook instead.","The completeModuleRegistrations function as been removed use the useDeferredRegistrations hook instead.","The completeLocalModulesRegistrations function has been removed use the useDeferredRegistrations hook instead.","The completeRemoteModuleRegistrations function has been removed use the useDeferredRegistrations hook instead.","The useSession hook has been removed, define your own React context instead.","The useIsAuthenticated hook has been removed, define your own React context instead.","The sessionAccessor option has been removed from the FireflyRuntime options, define your own React context instead.","The ManagedRoutes placeholder has been removed, use PublicRoutes and ProtectedRoutes instead."]},{"l":"Renamed","p":["The setMswAsStarted function has been renamed to setMswIsReady.","A route definition $name option has been renamed to $id.","The registerRoute parentName option has been renamed to parentId."]},{"l":"Dependencies updates","p":["The @squide/firefly package now has a peerDependency on @tanstack/react-query.","The @squide/firefly package doesn't have a peerDependency on react-error-boundary anymore.","The @squide/firefly package doesn't support react-router-dom@6* anymore, remove the reacy-router-dom dependency and update to react-router@7*."]},{"l":"Deprecation","p":["The registerLocalModules function has been deprecated, use the bootstrap function instead.","The registerRemoteModules function has been deprecated, use the bootstrap function instead.","The setMswAsReady```` function has been **deprecated**, use the bootstrap` function instead.","The RuntimeContext.Provider has been deprecated, use FireflyProvider instead.","The @squide/firefly-honeycomb package has been deprecated."]},{"l":"Update deferred registration functions signature","p":["As of v14.0, Deferred registration functions now receive a runtime instance as their first argument.","Before:","After:"]},{"l":"Removed support for deferred routes","p":["As of v9.0, Deferred registration functions no longer support route registration; they are now exclusively used for registering navigation items. Since deferred registration functions can now be re-executed whenever the global data changes, registering routes in deferred registration functions no longer makes sense as updating the routes registry after the application has bootstrapped could lead to issues.","This change is a significant improvement for Squide's internals, allowing us to eliminate quirks like:","Treating unknown routes as protected: When a user initially requested a deferred route, Squide couldn't determine if the route was public or protected because it wasn't registered yet. As a result, for that initial request, the route was considered protected, even if the deferred registration later registered it as public.","Mandatory wildcard * route registration: Previously, Squide's bootstrapping would fail if the application didn't include a wildcard route.","Before:","Now:"]},{"l":"Conditional routes","p":["To handle direct access to a conditional route, each conditional route's endpoint should return a 403 status code if the user is not authorized to view the route. Those 403 errors should then be handled by the nearest error boundary."]},{"l":"Plugin's constructors now requires a runtime instance","p":["Prior to v9.0, plugin instances received the current runtime instance through a _setRuntime function. This approach caused issues because some plugins required a reference to the runtime at instantiation. To address this, plugins now receive the runtime instance directly as a constructor argument.","Before:","Now:"]},{"l":"Plugins now registers with a factory function","p":["Prior to v9.0, the FireflyRuntime accepted plugin instances as options. Now plugins should be registered with the initializeFirefly function which accepts factory functions instead of plugin instances. This change allows plugins to receive the runtime instance as a constructor argument.","Before:","Now:"]},{"l":"Rewrite of the AppRouter component","p":["v9.0 features a full rewrite of the AppRouter component. The AppRouter component used to handle many concerns like global data fetching, deferred registrations, error handling and a loading state. Those concerns have been delegated to the consumer code, supported by the new useIsBootstrapping, usePublicDataQueries, useProtectedDataQueries and useDeferredRegistrations hooks.","Before:","Now:"]},{"l":"Use the initializeFirefly function","p":["Versions v9.3, v11.0 and v12.0 introduce changes to how the FireflyRuntime instance should be created and how the modules should be registered.","Before:","Now:"]},{"l":"Rename RuntimeContext.Provider to FireflyProvider","p":["v11.0 introduces the FireflyProvider alias for RuntimeContext.Provider. This change is optionnal as both are still supported, but strongly encouraged.","Before:","Now:"]},{"l":"Replace react-router-dom with react-router","p":["v10 introduces an update to React Router v7. In React Router v7, react-router-dom is no longer required, as the package structure has been simplified. All necessary imports are now available from either react-router or react-router/dom."]},{"l":"Preparation","p":["Before migrating to React Router v7, it is highly recommended to read React Router migration guide and activate the \"future flags\" one by one to minimize breaking changes.","Before:","Now:","If your application is already on React Router v7, you can ignore this advice."]},{"l":"Update dependencies","p":["Open a terminal at the root of the project workspace and use the following commands to remove react-router-dom and install react-router@latest:"]},{"l":"Update Imports","p":["In your code, update all imports from react-router-dom to react-router, except for RouterProvider, which must be imported from react-router/dom.","Before:","Now:","According to React Router migration guide, you can use the following command to update the imports from react-router-dom to react-router:"]},{"l":"New hooks and functions","p":["A new useIsBoostrapping hook is now available.","A new useDeferredRegistrations hook is now available.","A new usePublicDataQueries hook is now available.","A new useProtectedDataQueries hook is now available.","A new isGlobalDataQueriesError function is now available.","A new registerPublicRoute function is now available."]},{"l":"Improvements","p":["Deferred registration functions now always receive a data argument.","Deferred registration functions now receives a new operations argument.","Navigation items now include a $canRender option, enabling modules to control whether a navigation item should be rendered."]},{"l":"New $id option for navigation items","p":["Navigation items now supports a new $id option. Previously, most navigation item React elements used a key property generated by concatenating the item's level and index, which goes against React's best practices:","It wasn't that much of a big deal since navigation items never changed once the application was bootstrapped. Now, with the deferred registration functions re-executing when the global data changes, the registered navigation items can be updated post-bootstrapping. The new $id option allows the navigation item to be configured with a unique key at registration, preventing UI shifts.","The configured $id option is then passed as a key argument to the useRenderedNavigationItems rendering functions:","If no $id is configured for a navigation item, the key argument will be a concatenation of the level and index argument."]},{"l":"Migrate an host application","p":["Add a dependency to @tanstack/react-query.","Add an $id option to the navigation item registrations. View example","Add or update the AuthenticationBoundary component to use the new useIsAuthenticated hook. Global data fetch request shouldn't be throwing 401 error anymore when the user is not authenticated. View example","Convert all deferred routes into static routes. View example","Create a TanStackSessionManager class and the SessionManagerContext. Replace the session's deprecated hooks by creating the customs useSession and useIsAuthenticated hooks. View example","errorElement is removed and somewhat replaced by a root error boundary","fallbackElement becomes useIsBootstrapping","Follow these steps to migrate an existing host application:","onCompleteRegistrations becomes useDeferredRegistrations","onLoadProtectedData+ isProtectedDataLoaded becomes useProtectedDataQueries","onLoadPublicData+ isPublicDataLoaded becomes usePublicDataQueries","Remove the react-router-dom dependency and update to react-router@7*. View example","Remove the sessionAccessor option from the FireflyRuntime instance. Update the BootstrappingRoute component to create a TanStackSessionManager instance and share it down the component tree using a SessionManagedContext provider. View example","Rename RuntimeContext.Provider for FireflyProvider. View example","Replace the ManagedRoutes placeholder with the new PublicRoutes and ProtectedRoutes placeholders. View example","Replace the registerLocalModules, registerRemoteModules, setMswAsReady function and the FireflyRuntime by the initializeFirefly function. View example","Transition to the new AppRouter component. View example","Update the AuthenticatedLayout component to use the new key argument. View example","Update the AuthenticatedLayout component to use the session manager instance to clear the session. Retrieve the session manager instance from the context defined in the BootstrappingRoute component using the useSessionManager hook. View example"]},{"l":"useMsw","p":["If the application register MSW request handlers with the runtime.registerRequestHandlers function, add the useMsw property to the initializeFirefly function:"]},{"l":"waitForPublicData, waitForProtectedData","p":["The AppRouter component accepts the waitForPublicData, and waitForProtectedData properties. These properties are forwarded directly to the Squide bootstrapping flow state machine, where they are used to determine its initial state.","If the application uses the usePublicDataQueries, add the waitForPublicData property to the AppRouter component:","If the application uses the useProtectedDataQueries, add the waitForProtectedData property to the AppRouter component:","Otherwise, don't define any of those three properties on the AppRouter component."]},{"l":"Root error boundary","p":["When transitioning to the new AppRouter component, make sure to nest the RootErrorBoundary component within the AppRouter component's render function.","Before:","Now:"]},{"l":"Migrate a module","p":["The changes have minimal impact on module code. To migrate an existing module, follow these steps:","Remove the react-router-dom dependency and update to react-router@7*. View example","Add a runtime argument as the first parameter of deferred registration functions. View example","Convert all deferred routes into static routes. View example","Add a $id option to the navigation item registrations. View example","Ensure that modules registering deferred routes are updated to convert those routes into static routes and are deployed before the host application. Failure to do so may lead to runtime errors in the production environment."]},{"l":"Isolated development","p":["If your module is set up for isolated development, ensure that you also apply the host application migration steps to your isolated setup."]}],[{"l":"Migrate to Rsbuild","p":["This is an experimental feature.","Rsbuild is a high-performance build tool powered by Rspack, a Rust-based port of webpack designed for efficiency and speed. Squide firefly introduces a new @squide/firefly-rsbuild-configs package to improve it's developer experience with modern web development tooling. This package provides ready-to-use Rsbuild configurations specifically tailored for Squide applications.","To migrate from @squide/firefly-webpack-configs to @squide/firefly-rsbuild-configs, based on your project type, read the reference documentation and execute the following steps \uD83D\uDC47"]},{"l":"Host application"},{"l":"Update packages","p":["Open a terminal at the root of the host application project and install the following packages:","Then, in the same terminal, remove the following packages:","If your host application project uses SWC for tests, you may want to keep the @swc/core and @workleap/swc-configs packages."]},{"l":"Update files"},{"l":"webpack.build.js","p":["Rename the file from webpack.build.js to rsbuild.build.ts.","Then, open the rsbuild.build.ts file and apply the following changes:","Replace @squide/firefly-webpack-configs for @squide/firefly-rsbuild-configs.","Remove import { swcConfig } from ./swc.build.js.","Remove the first argument of the defineBuildHostConfig function.","Remove // @ts-check.","Before:","After:"]},{"l":"webpack.dev.js","p":["Rename the file from webpack.dev.js to rsbuild.dev.ts.","Then, open the rsbuild.build.ts file and and apply the following changes:","Replace @squide/firefly-webpack-configs for @squide/firefly-rsbuild-configs.","Remove import { swcConfig } from ./swc.build.js.","Remove the first argument of the defineDevHostConfig function.","Remove // @ts-check.","Before:","After:"]},{"l":"webpack.common.js (optional)","p":["Rename the file from webpack.common.js to rsbuild.common.ts.","Then, open the rsbuild.common.ts file and and apply the following changes:","Use typings for ModuleFederationShared.","Use typings for Features.","Remove // @ts-check.","Before:","After:"]},{"l":"swc.build.js","p":["Delete the swc.build.js file."]},{"l":"swc.dev.js","p":["Delete the swc.dev.js file."]},{"l":"index.ts","p":["Delete the index.ts file."]},{"l":"bootstrap.tsx","p":["Rename the bootstrap.tsx file for index.tsx."]},{"l":"Update scripts"},{"l":"build","p":["Update the build script to run Rsbuild instead of webpack.","Before:","After:"]},{"l":"dev","p":["Update the dev script to run Rsbuild instead of webpack.","Before:","After:"]},{"i":"try-it-rocket","l":"Try it \uD83D\uDE80","p":["Start the application in a development environment using the dev script. Everything should run smoothly and you should see the homepage of your application. Even if the remote modules of your application are still bundled with webpack, they should be available."]},{"l":"Remote module"},{"i":"update-packages-1","l":"Update packages","p":["Open a terminal at the root of the remote module project and install the following packages:","Then, in the same terminal, remove the following packages:","If your remote module project uses SWC for tests, you may want to keep the @swc/core and @workleap/swc-configs packages."]},{"i":"update-files-1","l":"Update files"},{"i":"webpackbuildjs-1","l":"webpack.build.js","p":["Rename the file from webpack.build.js to rsbuild.build.ts.","Then, open the rsbuild.build.ts file and apply the following changes:","Replace @squide/firefly-webpack-configs for @squide/firefly-rsbuild-configs.","Remove import { swcConfig } from ./swc.build.js.","Remove the first argument of the defineBuildRemoteModuleConfig function.","Remove // @ts-check.","Before:","After:"]},{"i":"webpackdevjs-1","l":"webpack.dev.js","p":["Rename the file from webpack.dev.js to rsbuild.dev.ts.","Then, open the rsbuild.dev.ts file and apply the following changes:","Replace @squide/firefly-webpack-configs for @squide/firefly-rsbuild-configs.","Remove import { swcConfig } from ./swc.dev.js.","Remove the first argument of the defineDevRemoteModuleConfig function.","Remove // @ts-check.","Before:","After:"]},{"i":"webpackcommonjs-optional-1","l":"webpack.common.js (optional)","p":["Rename the file from webpack.common.js to rsbuild.common.ts.","Then, open the rsbuild.common.ts file and and apply the following changes:","Use typings for ModuleFederationShared.","Use typings for Features.","Remove // @ts-check.","Before:","After:"]},{"i":"swcbuildjs-1","l":"swc.build.js","p":["Delete the swc.build.js file."]},{"i":"swcdevjs-1","l":"swc.dev.js","p":["Delete the swc.dev.js file."]},{"i":"update-scripts-1","l":"Update scripts"},{"i":"build-1","l":"build","p":["Update the build script to run Rsbuild instead of webpack.","Before:","After:"]},{"i":"dev-1","l":"dev","p":["Update the dev script to run Rsbuild instead of webpack.","Before:","After:"]},{"i":"try-it-rocket-1","l":"Try it \uD83D\uDE80","p":["Start the host application and the migrated remote module in development mode using the dev script. Everything should run smoothly and you should see the homepage of your application. Even if the host application is still bundled with webpack, the application should be available."]},{"l":"Local module"},{"i":"update-packages-2","l":"Update packages","p":["Open a terminal at the root of the local module project and install the following packages:","Then, in the same terminal, remove the following packages:","If your local module project uses SWC for tests, you may want to keep the @swc/core and @workleap/swc-configs packages."]},{"i":"update-files-2","l":"Update files"},{"l":"webpack.config.js","p":["Rename the file from webpack.config.js to rsbuild.config.ts.","Then, open the rsbuild.config.ts file and apply the following changes:","Replace @squide/firefly-webpack-configs for @squide/firefly-rsbuild-configs.","Remove import { swcConfig } from ./swc.dev.js.","Remove the first argument of the defineDevRemoteModuleConfig function.","Remove // @ts-check.","Before:","After:"]},{"l":"swc.config.js","p":["Delete the swc.config.js file."]},{"i":"update-scripts-2","l":"Update scripts"},{"l":"dev-isolated","p":["Update the dev-isolated script to run Rsbuild instead of webpack.","Before:","After:"]},{"i":"try-it-rocket-2","l":"Try it \uD83D\uDE80","p":["Start the host application and the migrated local module in development mode using the dev script. Everything should run smoothly and you should see the homepage of your application. Even if the host application is still bundled with webpack, the application should be available."]},{"l":"Sample applications","p":["For additional examples, have a look at Squide's sample applications:","basic","endpoints"]}],[{"l":"Migrate to Just-In-Time packages","p":["Using Just-in-Time packages is a great way to reduce the configuration complexity of your monorepo. Using a Just-In-Time package strategy allows you to directly consume TypeScript files from library projects into applications without having to pre-compile them. Instead, the applications themselves will compile the TypeScript packages at build time.","For more information about Just-in-Time packages, refer to this documentation.","To migrate your library projects (e.g., utility packages, shared packages, local modules, etc.) to JIT packages, based on your project type, execute the following steps \uD83D\uDC47"]},{"l":"Internal package"},{"l":"Remove packages","p":["Open a terminal at the root of the host application project and remove the following packages:"]},{"l":"Update files"},{"l":"package.json","p":["Open the package.json file and update the exports field to point to the library project's entry file. In this example, the entry file is index.ts.","Before:","After:"]},{"l":"tsconfig.json","p":["Open the tsconfig.json file and remove the compilerOptions.paths entries for library projects that enabled are Just-In-Time.","Before:","After:"]},{"l":"tsup.build.ts","p":["Delete the tsup.build.ts file."]},{"l":"tsup.dev.ts","p":["Delete the tsup.dev.ts file."]},{"l":"nodemon.json (optional)","p":["Delete the nodemon.json file."]},{"l":"Update scripts","p":["Remove the dev and build scripts."]},{"l":"Registry package"},{"l":"Remove packages (optional)","p":["Open a terminal at the root of the host application project and remove the following packages:"]},{"i":"update-files-1","l":"Update files"},{"i":"packagejson-1","l":"package.json","p":["Open the package.json file and move the export field value to the publishConfig field.","Before:","After:","Then, update the exports field to point to the library project's entry file. In this example, the entry file is index.ts."]},{"i":"tsconfigjson-1","l":"tsconfig.json","p":["Open the tsconfig.json file and remove the compilerOptions.paths entries for library projects that enabled are Just-In-Time.","Before:","After:"]},{"i":"tsupdevts-1","l":"tsup.dev.ts","p":["Delete the tsup.dev.ts file."]},{"i":"nodemonjson-optional-1","l":"nodemon.json (optional)","p":["Delete the nodemon.json file."]},{"i":"update-scripts-1","l":"Update scripts","p":["Remove the dev script."]}],[{"l":"Troubleshooting"},{"l":"Set the runtime mode to development","p":["In an effort to optimize the development experience, Squide can be bootstrapped in development or production mode. To troubleshoot a persistent issue, make sure that the runtime mode is development:"]},{"l":"Troubleshoot a production issue","p":["Frontend production issues are best troubleshoot using LogRocket. To output log entries to LogRocket's session replay, install the @workleap/logrocket package and provide an instance of LogRocket to the initializeFirefly function:","For troubleshooting frontend production issues, we recommend using LogRocket. To capture log entries in LogRocket session replays, install the @workleap/logrocket package and pass an instance of LogRocketLogger to the initializeFirefly function:"]},{"l":"React context values are undefined","p":["If your application utilize remote modules and you are encountering undefined values when providing a React context from the host application and consuming the context in modules, it is likely due to two possible reasons: either you have two instances of React, or you have multiple instances of that React context.","To resolve this issue:","Ensure that the react and react-dom dependencies are shared as singletons between the host application and the remote modules. A React context value cannot be shared between different parts of an application that use different instances of React.","Confirm that the shared React context resides in a library shared as a singleton.","If you are using eager shared dependencies, ensure that ONLY the host application configures these dependencies as eager.","If the issue persists, update your host application and remote module's webpack build configuration with the optimize: false option. Afterward, build the bundles and serve them. Open a web browser, access the DevTools, switch to the Network tab (ensure that JS files are listed), navigate to the application's homepage, and inspect the downloaded bundle files. The problematic React context definition should appear only once; otherwise, you may have multiple instances of the React context.","For additional information on shared dependency versioning, please refer to the add a shared dependency guide."]},{"l":"Console logs","p":["To faciliate the debugging of a Squide application bootstrapping flow, a lot of information is logged into the console. We recommend using these logs if you suspect that something is wrong with the bootstrapping process of your application."]},{"l":"Local modules","p":["[squide] Found 4 local modules to register.","[squide] 1/4 Registering local module.","[squide] 1/4 Local module registration completed."]},{"l":"Routes registration","p":["[squide] The following route registration is pending until managed-routes-placeholder is registered.","[squide] The following route has been registered as a children of the managed-routes-placeholder route.","[squide] The following route has been registered."]},{"l":"Navigation items registration","p":["[squide] The following static navigation item registration is pending until the officevibe section of the root menu is registered","[squide] The following static navigation item has been registered to the /federated-tabs menu for a total of 2 static items.","[squide] The following deferred navigation item has been registered to the root menu for a total of 4 deferred items."]},{"l":"Mock Service Worker registration","p":["[squide] The following MSW request handlers has been registered: [...]","[squide] MSW is ready."]},{"l":"AppRouter logs","p":["[squide] AppRouter state updated: {...}","[squide] The following action has been dispatched to the AppRouter reducer: {...}"]},{"l":"i18n logs","p":["[squide] Registered a new i18next instance with key shell: {...}","[squide] The language has been changed to fr-CA.","[squide] Detected fr-CA as user language."]},{"l":"env-vars registration","p":["[squide] The following environment variables has been registered: {...}"]},{"l":"Modules registration"},{"l":"Remote modules","p":["[squide] Found 1 remote module to register.","[squide] 1/1 Loading module register of remote remote1.","[squide] 1/1 Registering module register of remote remote1.","[squide] 1/1 The registration of the remote remote1 is completed."]},{"l":"Deferred registrations","p":["[squide] 1/1 Registering the deferred registrations for module register of remote remote1.","[squide] 1/1 Registered the deferred registrations for module register of remote remote1.","[squide] 3/3 Updating local module deferred registration.","[squide] 3/3 Updated local module deferred registration."]},{"l":"Module federation logs","p":["[squide] Module Federation shared scope is available: {...}"]},{"l":"Ready","p":["[squide] Modules are ready."]}],[{"l":"Samples"},{"l":"Squide \"basic\" sample","p":["Host application","Remote module","Another remote module","Local module","Shared application shell","Shared library","Host sample"]},{"l":"Squide sample with \"endpoints\"","p":["Host application","Remote module","Local module","Shared application shell","Layouts library","i18next library","Shared library","Host sample","Isolated remote module sample"]}],[{"l":"About","p":["To ask a question or propose an idea, feel free to start a new discussion on Github. If you found a bug, please open an issue on Github."]},{"l":"Contributing","p":["Have a look at the contributor's documentation."]},{"l":"License","p":["See the LICENSE on Github."]}]]